\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}

\title{Automatic differentiation of quantum programs}
\author{Nathan Killoran}

\begin{document}

\maketitle

\begin{abstract}
This document sketches out some basic ideas for automatic differentiation when the computation includes quantum circuits.
\end{abstract}

\section{Basic ideas}
In many applications of numerical computation, it is convenient to not only evaluate functions $f(x)$ numerically, but also to numerically evalaute the derivatives of these functions with respect to arbitrary parameters, $\frac{\partial}{\partial\theta}f(x)$.
The idea of ``automatic differentiation'' is to do this in an automatic way. That is, a user specifies the function $f$, through a sequence of elementary operations (these can be either mathematical or control flow expressions). Since the derivatives of most (all?) of these elementary operations are well-known, we can automatically build up the derivative of the function $f$ by systematically inspecting the code which specifies the function itself and assigning a (known) derivative function for each step in the computation.

In the case of quantum computations, we can also represent some functions via a sequence of elementary operations. The issue is that, in general, these computations can become so complex that computing them with a classical device becomes unscalable and inefficient. Computing them with a quantum device can, in principle, be much more efficient. Essentially, there is a mismatch with the elementary operations available for classical computers and those available for quantum computers. Some parts of a computation end up containing far too many operations to effectively perform on a classical device, whereas replacing that subgraph with a quantum hardware allows us to compute it with a quantum circuit which has many fewer nodes. 

\section{Design rationale}

We list here some specific considerations in order to build a functional core library. In the future, we could consider expanding and generalizing these ideas.

\paragraph{Mathematical model}
Our basic objects will be \emph{operations}, i.e., functions that transform inputs $x$ to outputs $f(x)$. Our notion of operations is quite broad: it includes the usual mathematical functions, control flow statements, computer algorithms, stochatic functions, random variables, and more. It also includes quantum computations, since we can consider the inputs $x$ to be quantum states, and the outputs $f(x)$ to be quantum states or measurement results on quantum states. 

\paragraph{Computational Graph}
One we have our basic objects, we will want to compose them in various ways. We take a data-processing picture, in which information is processed in a directed manner, with no back-action. Hence, we represent all computation using a directed acyclic graph (DAG). This is a common picture in classical computing. In quantum computing, we recognize that the standard circuit model also fits into this description. 

\paragraph{Quantum information processing}
In the quantum case, the nodes in the graph are all quantum operations, while the edges in the graph represent the flow of quantum information. At this stage, we do not specify which physical systems are being used. 

\paragraph{Quantum-classical interface}
For interfacing with classical systems, it is convenient to encapsulate quantum computations into complete \emph{circuits}, such that the inputs, outputs, and control parameters of the circuit are all modelled as classical objects. The quantum circuits we consider contain the following basic operations: state preparations, transformations via programmable quantum gates or channels, and measurements. Hence, the role of a quantum circuit is to transform classical data into classical data (though in a very special way).

\paragraph{Quantum circuit outputs}
The final outputs of quantum circuits should be classical information obtained via measurements. Measurements of quantum systems are stochastic, so we have two options: either the classical information is allowed to be the one-shot samples, or we use the same quantum circuit many times to obtain expectation values of the measurement results. Although we could adapt to one-shot measurements in future work, for now, we will assume that the outgoing classical information of a quantum circuit is in the form of expectation values. 

\paragraph{Static vs dynamic graphs}
The difference between a static versus dynamic graph picture is similar to the difference between a compiled computer program and an interpreted one. For concreteness, we will focus on a static graph, but it would be cool to see if our hybrid quantum/classical picture could also fit within a dynamic graph picture. 

\paragraph{Physical systems}
We would like to include both the CV and the qubit models. Obviously we include the CV model because it is the approach we are taking at Xanadu. We include the qubit model because we want PennyLane to be platform agnostic, and most (all?) other vendors are pursuing the qubit model.

\paragraph{Differentiation support} 
A primary ingredient of the library will be the ability to compute derivatives of functions, allowing for gradient-based optimization. Despite valiant attempts, we do not yet know how to compute exact gradients of CV model circuits. Hence, in order to include both CV and qubit models, we should support both automatic differentiation and numerical differentiation (e.g., via finite differences).

\paragraph{Automatic differentiation}
We would like to support ``hybrid'' automatic differentiation, where we have a function $f$, represented via a DAG which can contain both classical and quantum nodes, and we use the same hardware to evaluate both the function $f(x)\big|_{x=a}$ and its gradients $\nabla_\theta f(x)\big|_{x=a}$. This will be the most novel feature of the library.

\end{document}