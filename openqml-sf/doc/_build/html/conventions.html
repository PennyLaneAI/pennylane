
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link href="https://fonts.googleapis.com/css?family=Noto+Serif" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap-theme.min.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/nanoscroller.css" />
  <script defer src="https://use.fontawesome.com/releases/v5.0.2/js/all.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['I',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0],
           expect: ["\\langle #1 \\rangle",1],
           pde: ["\\frac{\\partial}{\\partial \#1}",1],
           R: ["\\mathbb{R}",0],
           C: ["\\mathbb{C}",0],
           Ad: ["\\text{Ad}",0],
           Var: ["\\text{Var}",0],
           bx: ["\\mathbf{x}", 0],
           bm: ["\\boldsymbol{\#1}",1]
         }
       }
     });
     </script>
  
    <title>Conventions &#8212; OpenQML 0.1.0 documentation</title>
    <link rel="stylesheet" href="_static/xanadu.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="References and further reading" href="references.html" />
    <link rel="prev" title="Automatic differentiation of quantum functions" href="autograd_quantum.html" />
  
  <link rel="apple-touch-icon" href="_static/logo_new.png" />
  
   

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="references.html" title="References and further reading"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="autograd_quantum.html" title="Automatic differentiation of quantum functions"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">OpenQML 0.1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column" class="nano css-transitions-only-after-page-load">
    <div class="sphinxsidebar nano-content"><a href="http://xanadu.ai" class="text-logo">
	<img src="_static/logo_new.png" class="logo active" width=80%></img>
	<img src="_static/logo_new_small.png" class="logo-small" width=80%></img>
	<!-- <span id="project-name">OpenQML</span> -->
</a>
<div class="sidebar-block search-block">
  <div class="sidebar-wrapper">
  <!-- <div id="project-name">OpenQML</div> -->
    <a href="
    index.html">
      <div id="project-name">
        <!-- <img src="_static/strawberry_fields.png" width=100%></img> -->
        <p style="font-size:28px;margin:0;padding:0;line-height:1;text-transform:none!important">OpenQML</p>
      </div>
    </a>
    <div id="main-search">
      <form class="form-inline" action="search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
<div class="sidebar-block">
<!--   <div class="sidebar-wrapper">
    <h2>Table Of Contents</h2>
  </div> -->
  <div class="sidebar-toc">
    
    
      <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="installing.html">Installation and downloads</a></li>
<li class="toctree-l1"><a class="reference internal" href="research.html">Research and contribution</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="autograd_quantum.html">Automatic differentiation of quantum functions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Conventions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#measurements-in-qm">Measurements in QM</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multiple-measurements">Multiple measurements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#observables-and-measurements-in-openqml-and-strawberry-fields">Observables and measurements in OpenQML and Strawberry Fields</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References and further reading</a></li>
</ul>
<p class="caption"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="core.html">Core classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="circuit.html">Quantum circuits</a></li>
</ul>
<p class="caption"><span class="caption-text">Plugins</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="plugins.html">Plugin system</a></li>
<li class="toctree-l1"><a class="reference internal" href="plugins/included_plugins.html">Included plugins</a></li>
</ul>

    
  </div>
</div>
      
    </div>
  </div>
        <div id="content">
          <div id="right-column">
            
            <div role="navigation" aria-label="breadcrumbs navigation">
              <ol class="breadcrumb">
                <li><a href="index.html">Docs</a></li>
                
                <li>Conventions</li>
                    <li style="float: right;" class="showsource">
                      <a href="https://github.com/XanaduAI/openqml/blob/master/doc/conventions.rst" class="reference-external" rel="nofollow">
                        <i class="fab fa-github"></i>
                        Show on GitHub
                      </a>
                    </li>
                  <li style="float: right;" class="showsource">
                    <a href="_sources/conventions.rst.txt" class="reference-external" rel="nofollow">
                      Show Source
                    </a>
                  </li>
              </ol>
            </div>
            
            <div class="document clearer body">
              
  <div class="section" id="conventions">
<h1>Conventions<a class="headerlink" href="#conventions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="measurements-in-qm">
<h2>Measurements in QM<a class="headerlink" href="#measurements-in-qm" title="Permalink to this headline">¶</a></h2>
<p>Let us have a quick recap of how measurements work in quantum mechanics.
A general (full) measurement is defined by a set of measurement operators <span class="math notranslate">\(\{A_i\}\)</span>,
with the property</p>
<div class="math notranslate">
\[\sum_k A_k^\dagger A_k = \I.\]</div>
<p>If the state before the measurement is <span class="math notranslate">\(\rho\)</span>, the probability of obtaining result <span class="math notranslate">\(k\)</span> is</p>
<div class="math notranslate">
\[p_{A_k} = \tr(A_k^\dagger A_k \rho).\]</div>
<p>The aforementioned property of the measurement operators guarantees that the probabilities sum up to one for
any state <span class="math notranslate">\(\rho\)</span>.
If the measurement yields the result <span class="math notranslate">\(k\)</span>, the (conditional) state after the measurement is</p>
<div class="math notranslate">
\[\rho_{A_k}' = \frac{A_k \rho A_k^\dagger}{p_{A_k}}.\]</div>
<p>If we ignore the outcome but wish to obtain the state after the measurement process,
we may take the convex combination of these conditional states multiplied by their respective probabilities:</p>
<div class="math notranslate">
\[\rho_{A}' = \sum_k p_{A_k} \rho_{A_k}' = \sum_k A_k \rho A_k^\dagger.\]</div>
<p>If each measurement outcome is associated with a real number <span class="math notranslate">\(a_k\)</span>, we may obtain the expectation value
of this random variable as</p>
<div class="math notranslate">
\[\expect{A} = \sum_k a_k p_{A_k} = \tr(\sum_k a_k A_k^\dagger A_k \rho) = \tr(\tilde{A} \rho),\]</div>
<p>where <span class="math notranslate">\(\tilde{A} = \sum_k a_k A_k^\dagger A_k\)</span> is a hermitian operator.</p>
<p>A special case called a <em>projective measurement</em> is obtained when the measurement operators
<span class="math notranslate">\(\{A_i\}\)</span> are a set of mutually orthogonal projectors:
<span class="math notranslate">\(A_i^\dagger = A_i\)</span> and <span class="math notranslate">\(A_i A_j = \delta_{ij} A_i\)</span>.
In this case many of the above equalities are simplified, for example
<span class="math notranslate">\(\sum_k A_k^\dagger A_k = \sum_k A_k = \I\)</span> and <span class="math notranslate">\(p_{A_k} = \tr(A_k \rho)\)</span>.
Now the operator <span class="math notranslate">\(\tilde{A} = \sum_k a_k A_k\)</span> is called a <em>hermitian observable</em> corresponding to the measurement,
and it is given directly as a spectral decomposition in terms of the projectors.
Moreover, in this case we conveniently have for any analytic function <span class="math notranslate">\(f\)</span></p>
<div class="math notranslate">
\[\expect{f(A)} = \sum_k f(a_k) p_{A_k} = \tr(\sum_k f(a_k) A_k \rho) = \tr(f(\tilde{A}) \rho).\]</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">One can consider unitary gates (which are deterministic operations) as “measurements” with just a single operator, the unitary itself.</p>
</div>
</div>
<div class="section" id="multiple-measurements">
<h2>Multiple measurements<a class="headerlink" href="#multiple-measurements" title="Permalink to this headline">¶</a></h2>
<p>Two consecutive measurements <span class="math notranslate">\(\{A_i\}\)</span> and <span class="math notranslate">\(\{B_i\}\)</span> can be combined into a single measurement
with the measurement operators <span class="math notranslate">\(C_{ji} = B_j A_i\)</span>:</p>
<div class="math notranslate">
\[p_{(B_j|A_i)} = \tr(B_j^\dagger B_j \rho_{A_i}') = \tr(B_j^\dagger B_j A_i \rho A_i^\dagger) / p_{A_i} = \tr(C_{ji} \rho C_{ji}^\dagger) / p_{A_i},\]</div>
<p>and thus the joint p.d.f. is obtained as</p>
<div class="math notranslate">
\[p_{(B_j, A_i)} = p_{(B_j|A_i)} p_{A_i} = \tr(C_{ji}^\dagger C_{ji} \rho).\]</div>
<p>Note that the relative order of the measurements in general matters, different orders produce different probability distributions.</p>
<p>If there are any unitaries between the measurements we may fold them into the latter measurement:
<span class="math notranslate">\(B_j U A_i = U (U^\dagger B_j U) A_i = U B_j' A_i\)</span>.</p>
<p>Things are greatly simplified if the measurement operators commute pairwise, <span class="math notranslate">\([A_i, B_j] = 0\)</span>.
In this case the joint p.d.f. does not depend on the order of the measurements. Furthermore,
the expectation values can be obtained as</p>
<div class="math notranslate">
\[ \begin{align}\begin{aligned}\expect{A} = \sum_{ij} a_i p_{(B_j, A_i)} = \sum_{ij} a_i \tr(B_j A_i \rho A_i^\dagger B_j^\dagger) = \tr(\sum_i a_i A_i^\dagger A_i \rho) = \tr(\tilde{A} \rho),\\\expect{B} = \sum_{ij} b_j p_{(B_j, A_i)} = \sum_{ij} b_j \tr(B_j A_i \rho A_i^\dagger B_j^\dagger) = \sum_i \tr(\tilde{B} A_i \rho A_i^\dagger) = \tr(\tilde{B} \rho).\end{aligned}\end{align} \]</div>
<p>If both A and B are projective measurements and they additionally commute, the combined measurement C is also projective.</p>
</div>
<div class="section" id="observables-and-measurements-in-openqml-and-strawberry-fields">
<span id="measurements"></span><h2>Observables and measurements in OpenQML and Strawberry Fields<a class="headerlink" href="#observables-and-measurements-in-openqml-and-strawberry-fields" title="Permalink to this headline">¶</a></h2>
<p>In Strawberry Fields we may perform state preparations, gates and measurements on the quantum register.
SF is currently designed to model a single execution of a quantum circuit in the lab.
The probability distribution of the results of a measurement is determined by the (reduced) system state at the time of the measurement.
Each measurement probabilistically collapses the system state, and thus the results of any following measurements may depend on the results of the preceding ones.
After the program is finished, in addition to the measured results we may treat the final state as an output of the circuit.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The DAG (Directed Acyclic Graph) used to describe the quantum circuit in SF corresponds (via transitive closure) to a strict partial order of the quantum operations.
We denote <span class="math notranslate">\(A &lt; B\)</span> if <span class="math notranslate">\(A\)</span> has to be executed before <span class="math notranslate">\(B\)</span>.</p>
</div>
<p>Assuming the program itself is deterministic, if there are no measurements we obtain the same final state each time (which in itself is a quantum probability distribution).
If there are measurements <span class="math notranslate">\(A, B, \ldots\)</span> in the program, each run of the program instead samples the joint p.d.f. of the measurement results,
which are not necessarily statistically independent.
Due to entanglement, even if two measurements seem independent on the circuit DAG (in the sense that neither <span class="math notranslate">\(A&lt;B\)</span> nor <span class="math notranslate">\(B&lt;A\)</span>),
their results of may depend on each other.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Example (ignoring normalization here): Consider the state <span class="math notranslate">\(\ket{00}+\ket{11}\)</span>. If we measure both of the two subsystems separately in the computational basis, for both measurements
0 and 1 are equally likely outcomes, but the results always are perfectly correlated.</p>
</div>
<p>However, if neither <span class="math notranslate">\(A&lt;B\)</span> nor <span class="math notranslate">\(B&lt;A\)</span>, the measurements necessarily commute, and the relative order in which the measurements are performed does not affect the joint p.d.f. of the results.
Furthermore, if we are only interested in the expectation values of the observables (and don’t care about correlations), we may compute them as shown in the previous section.</p>
<p>Let us now assume we wish to obtain (estimates for) the expectation values <span class="math notranslate">\(\expect{A}, \expect{B}, \ldots\)</span> of a set of measurements using SF.</p>
<ol class="arabic simple">
<li>The simplest method is to run the circuit <span class="math notranslate">\(n\)</span> times and average the results for each measurement, resulting in an estimate for the expectation values.
This is computationally inefficient for simulators, but may be a valid method for a hardware backend.</li>
<li>If <span class="math notranslate">\(A\)</span> does not causally depend on any other measurements (this is always true for the first measurement we make in the program),
we may run the program until we reach <span class="math notranslate">\(A\)</span> and sample the state at that point <span class="math notranslate">\(n\)</span> times.
This will not work if <span class="math notranslate">\(A\)</span> depends on preceding measurements.
<strong>This feature is not yet implemented in SF.</strong>
Alternatively, for certain types of measurements we may extract the state object before <span class="math notranslate">\(A\)</span> happens,
and then call the appropriate expectation value method on it to obtain the EV directly.</li>
<li>The method in the previous item can be used for any number of measurements if they are all consecutive
(or made consecutive by eliminating unitaries between them as explained in the previous section, thereby modifying the measurement operators),
and all commute with each other.</li>
<li>The ideal solution would be to automate the the computation of expectation values of an arbitrary number of measurements
as efficiently as possible. At least it would be possible to topologically sort the circuit DAG into a Command sequence consisting of three parts, A+B+C,
where only B contains measurements and A and C are as long as possible. By isolating the measurements into a short program sequence
we may benefit by saving and re-using the state after A during the sampling in part B. If we are not interested in the final state, executing C is not necessary at all.</li>
</ol>
<p>When estimating expectation values like this, we will not obtain a specific collapsed state (and usually will not need one).
If one is needed, the option that makes the most sense for commuting measurements would probably be</p>
<div class="math notranslate">
\[\rho' = \sum_{ij\ldots} (A_i B_j \cdots) \rho (A_i B_j \cdots)^\dagger.\]</div>
<p>In summary, both <a class="reference internal" href="plugins/strawberryfields.html#module-openqml.plugins.strawberryfields" title="openqml.plugins.strawberryfields"><code class="xref py py-mod docutils literal notranslate"><span class="pre">openqml.plugins.strawberryfields</span></code></a> and <a class="reference internal" href="plugins/dummy_plugin.html#module-openqml.plugins.dummy_plugin" title="openqml.plugins.dummy_plugin"><code class="xref py py-mod docutils literal notranslate"><span class="pre">openqml.plugins.dummy_plugin</span></code></a> currently are only designed to return expectation values of measurements which are</p>
<ol class="arabic simple">
<li>projective,</li>
<li>grouped next to each other, and</li>
<li>all commute with each other.</li>
</ol>
</div>
</div>


            </div>
              
  <div class="footer-relations">
    
      <div class="pull-left">
        <a class="btn btn-xanadu" href="autograd_quantum.html" title="previous chapter (use the left arrow)"><i class="fas fa-arrow-left"></i> Previous</a>
      </div>
    
      <div class="pull-right">
        <a class="btn btn-xanadu" href="references.html" title="next chapter (use the right arrow)">Next <i class="fas fa-arrow-right"></i></a>
      </div>
    </div>
    <div class="clearer"></div>
  
          </div>
          <div class="clearfix"></div>
        </div>


    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="references.html" title="References and further reading"
             >next</a> |</li>
        <li class="right" >
          <a href="autograd_quantum.html" title="Automatic differentiation of quantum functions"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">OpenQML 0.1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="_static/js/bootstrap.js"></script>
<script type="text/javascript" src="_static/js/nanoscroller.min.js"></script>
<script type="text/javascript">
    $(".nano").nanoScroller();
</script>
<script type="text/javascript">
    if ($('.current').length) {
        var target = $('.current')[0]
        var rect = target.getBoundingClientRect();
        if (rect.bottom > window.innerHeight) {
            $('.text-logo').addClass('active');
            $('.logo').removeClass('active');
            $('.logo-small').addClass('active');
            $(".nano").nanoScroller({ scrollTo: $('.current') });
        } else {
            // $('.text-logo').addClass('active');
            // $('.logo').removeClass('active');
            // $('.logo-small').addClass('active');
            $(".nano").nanoScroller({ scrollTop: 93 });
        }
    }
    if ($('#search-documentation').length) {} else {
        $(".nano").on("update", function(event, values){
            $('.text-logo').toggleClass('active', $('.sphinxsidebar').scrollTop() > 0);
            var act = $('.text-logo').hasClass('active');
            if(act){
                $('.logo').removeClass('active');
                $('.logo-small').addClass('active');
            }
        });
    }
    $(".nano").bind("scrolltop", function(e){
        $('.logo-small').removeClass('active');
        $('.logo').addClass('active');
    });
    $(document).ready(function () {
        $(".css-transitions-only-after-page-load").each(function (index, element) {
            setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
        });
    });
</script>
  <div class="footer">
    Copyright 2018, Xanadu Inc. Documentation created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>