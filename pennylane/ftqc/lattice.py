# Copyright 2025 Xanadu Quantum Technologies Inc.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# pylint: disable=protected-access, inconsistent-return-statements
"""
This file defines classes and functions for creating lattice objects that store topological
connectivity information.
"""

from typing import Dict, List, Union
from enum import Enum

import networkx as nx


class Lattice:
    """Represents a qubit lattice structure.

    This Lattice class, inspired by the design of :class: `~pennylane.spin.Lattice`, leverages `NetworkX` to represent the relationships within the lattice structure.

        Args:
            lattice_shape: Name of the lattice shape.
            graph (nx.Graph): A NetworkX undirected graph object. If provided, `nodes` and `edges` are ignored.
            nodes (List): Nodes to construct a graph object. Ignored if `graph` is provided.
            egdes (List): Edges to construct the graph. Ignored if `graph` is provided.
        Raises:
            ValueError: If neither `graph` nor both `nodes` and `edges` are provided.
    """

    # TODOs: To support braiding operations, Lattice should support nodes/edges addition/deletion.

    def __init__(
        self, lattice_shape: str, graph: nx.Graph = None, nodes: List = None, edges: List = None
    ):
        self._lattice_shape = lattice_shape
        if graph is None:
            if nodes is None and edges is None:
                raise ValueError(
                    "Neither a networkx Graph object nor nodes together with egdes are provided."
                )
            self._graph = nx.Graph()
            self._graph.add_nodes_from(nodes)
            self._graph.add_edges_from(edges)
        else:
            self._graph = graph

    @property
    def get_lattice_shape(self) -> str:
        r"""Returns the lattice shape name."""
        return self._lattice_shape

    @property
    def get_neighbors(self, node):
        r"""Returns the neighbors of a given node in the lattice.

        Args:
            node: a target node label.
        """
        return self._graph.neighbors(node)

    @property
    def get_nodes(self):
        r"""Returns all nodes in the lattice."""
        return self._graph.nodes

    @property
    def get_edges(self):
        r"""Returns all edges in the lattice."""
        return self._graph.edges

    @property
    def get_graph(self) -> nx.Graph:
        r"""Returns the underlying NetworkX graph object representing the lattice."""
        return self._graph


class LatticeShape(Enum):
    chain = 1
    square = 2
    rectangle = 2
    triangle = 2
    honeycomb = 2
    cubic = 3

class LatticeGraphGenerator(Enum):
    chain = "grid_graph"
    square = "grid_graph"
    rectangle = "grid_graph"
    cubic = "grid_graph"
    triangle = "triangular_lattice_graph"
    honeycomb = "hexagonal_lattice_graph"

def generate_lattice(dims: List[int], lattice) -> Lattice:
    r"""Generates a :class:`~pennylane.ftqc.Lattice` object with a given lattice dimensions and its shape name.

    Args:
        dims(List[int]): Dimensions for lattice generation. For lattices generated by `nx.grid_graph` ( ``'chain'``, ``'rectangle'``,  ``'square'``, ``'cubic'``), 
        `dims` contains the number of nodes in the each direction of grid. Per ``'honeycomb'`` or ``'triangle'``, the generated lattices will have dims[0] rows and dims[1]
        columns of hexagons or triangles.
        lattice (str): Shape of the lattice. Input values can be ``'chain'``, ``'square'``, ``'rectangle'``, ``'honeycomb'``, ``'triangle'``, ``'cubic'``.

    Returns:
        a :class:`~pennylane.ftqc.Lattice` object.

    Raises:
        ValueError: If the lattice shape is not supported or the dimensions are invalid.
    """
    # TODOs: Add default support to CSS, Shor, Foliation code lattices.

    lattice_shape = lattice.strip().lower()
    supported_shape = [shape.name for shape in LatticeShape]

    if lattice_shape not in supported_shape:
        raise ValueError(
            f"Lattice shape, '{lattice}' is not supported."
            f"Please set lattice to: {supported_shape}."
        )

    if LatticeShape[lattice_shape].value != len(dims):
        raise ValueError(f"For a {lattice_shape} lattice, the length of dims should {LatticeShape[lattice_shape].value} instead of {len(dims)}")
    
    lattice_generate_method = getattr(nx, LatticeGraphGenerator[lattice_shape].value)

    if LatticeGraphGenerator[lattice_shape].value == "grid_graph":
        lattice_obj = Lattice(lattice_shape, lattice_generate_method(dims))
        return lattice_obj
    
    if LatticeGraphGenerator[lattice_shape].value in ["triangular_lattice_graph", "hexagonal_lattice_graph"]:
        lattice_obj = Lattice(lattice_shape, lattice_generate_method(dims[0], dims[1]))
        return lattice_obj
