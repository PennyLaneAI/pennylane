# Copyright 2025 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests for the transform ``qml.transform.select_pauli_rot_phase_gradient``"""
from functools import partial
from itertools import product

import numpy as np
import pytest

import pennylane as qml
from pennylane.labs.transforms.select_pauli_rot_phase_gradient import (
    _binary_repr_int,
    _select_pauli_rot_phase_gradient,
    select_pauli_rot_phase_gradient,
)


def prepare_phase_gradient(wires):
    """Prepares the phase gradient."""
    ops = []
    for i, w in enumerate(wires):
        ops.append(qml.H(w))
        ops.append(qml.PhaseShift(-np.pi / 2**i, w))
    return ops


@pytest.mark.parametrize("string", list(product([0, 1], repeat=4)))
@pytest.mark.parametrize("p", [2, 3, 4])
def test_binary_repr_int(string, p):
    """Test that the binary representation or approximation of the angle is correct

    In particular, this tests that phi = (c1 2^-1 + c2 2^-2 + .. + cp 2^-p + ... + 2^-N) 4pi
    is correctly represented as (c1, c2, .., cp) for precision p
    """
    phi = np.sum([c * 2 ** (-i - 1) for i, c in enumerate(string)]) * 4 * np.pi
    string_str = "".join([str(i) for i in string])

    assert string_str[:p] == _binary_repr_int(phi, p)


@pytest.mark.parametrize("p", [2, 3, 4])
def test_units_select_pauli_rot_phase_gradient(p):
    """Test the operators generated by _select_pauli_rot_phase_gradient"""

    phis = [
        (1 / 2 + 1 / 4 + 1 / 8) * 2 * np.pi,
        (1 / 2 + 1 / 4 + 0 / 8) * 2 * np.pi,
        (1 / 2 + 0 / 4 + 1 / 8) * 2 * np.pi,
        (0 / 2 + 1 / 4 + 1 / 8) * 2 * np.pi,
    ]

    wire = "targ"
    control_wires = qml.wires.Wires([f"control_{i}" for i in range(2)])
    angle_wires = qml.wires.Wires([f"aux_{i}" for i in range(p)])
    phase_grad_wires = qml.wires.Wires([f"qft_{i}" for i in range(p)])
    work_wires = qml.wires.Wires([f"work_{i}" for i in range(p - 1)])

    ops = _select_pauli_rot_phase_gradient(
        phis,
        control_wires=control_wires,
        target_wire=wire,
        angle_wires=angle_wires,
        phase_grad_wires=phase_grad_wires,
        work_wires=work_wires,
    )

    for op in ops:
        assert op.name in ["QROM", "SemiAdder", "MultiControlledX", "Adjoint(QROM)"]


def test_wire_validation():
    """Test that an error is raised when phg wires are fewer than angle wires"""

    circ = qml.tape.QuantumScript([qml.SelectPauliRot([0.5, 0.5], [0], 1)])

    angle_wires = qml.wires.Wires([f"angle_{i}" for i in range(3)])
    phase_grad_wires = qml.wires.Wires([f"phg_{i}" for i in range(2)])
    work_wires = qml.wires.Wires([f"work_{i}" for i in range(2)])

    with pytest.raises(
        ValueError, match="phase_grad_wires needs to be at least as large as angle_wires"
    ):
        _ = select_pauli_rot_phase_gradient(
            circ,
            angle_wires=angle_wires,
            phase_grad_wires=phase_grad_wires,
            work_wires=work_wires,
        )


@pytest.mark.parametrize(
    "rot_axis",
    [
        "Z",
        "X",
        "Y",
    ],
)
def test_correctness_select_pauli_rot_phase_gradient(rot_axis):
    """Test that decomposition produce the correct solution"""

    precision = 4
    wire = "targ"
    angle_wires = [f"ang_{i}" for i in range(precision)]
    phase_grad_wires = [f"phg_{i}" for i in range(precision)]
    work_wires = [f"work_{i}" for i in range(precision - 1)]

    def phase_gradient(wires):
        # prepare phase gradient state
        for i, w in enumerate(wires):
            qml.H(w)
            qml.PhaseShift(-np.pi / 2**i, w)

    @partial(
        select_pauli_rot_phase_gradient,
        angle_wires=angle_wires,
        phase_grad_wires=phase_grad_wires,
        work_wires=work_wires,
    )
    @qml.qnode(qml.device("default.qubit"))
    def select_pauli_rot_circ(phis, control_wires, target_wire):
        phase_gradient(phase_grad_wires)  # prepare phase gradient state

        for wire in control_wires:
            qml.Hadamard(wire)

        qml.SelectPauliRot(phis, control_wires, target_wire, rot_axis=rot_axis)

        if rot_axis == "Y":
            qml.adjoint(qml.S)(target_wire)

        if rot_axis in ["X", "Y"]:
            qml.Hadamard(target_wire)

        qml.Select([qml.RZ(-phi, target_wire) for phi in phis], control=control_wires)

        if rot_axis in ["X", "Y"]:
            qml.Hadamard(target_wire)

        if rot_axis == "Y":
            qml.S(target_wire)

        for wire in control_wires:
            qml.Hadamard(wire)

        return qml.probs(wire)

    phis = [
        (1 / 2 + 1 / 4 + 1 / 8) * 2 * np.pi,
        (1 / 2 + 1 / 4 + 0 / 8) * 2 * np.pi,
        (1 / 2 + 0 / 4 + 1 / 8) * 2 * np.pi,
        (0 / 2 + 1 / 4 + 1 / 8) * 2 * np.pi,
    ]

    assert np.isclose(select_pauli_rot_circ(phis, control_wires=[0, 1], target_wire=wire)[0], 1)
