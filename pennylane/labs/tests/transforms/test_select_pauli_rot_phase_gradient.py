# Copyright 2025 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests for the transform ``qp.transform.select_pauli_rot_phase_gradient``"""

from functools import partial

import numpy as np
import pytest

import pennylane as qp
from pennylane.labs.transforms.select_pauli_rot_phase_gradient import (
    _binary_repr_int,
    _select_pauli_rot_phase_gradient,
    select_pauli_rot_phase_gradient,
)


def prepare_phase_gradient(wires):
    """Prepares the phase gradient state."""
    ops = []
    for i, w in enumerate(wires):
        ops.append(qp.H(w))
        ops.append(qp.PhaseShift(-np.pi / 2**i, w))
    return ops


@pytest.mark.parametrize(
    "phi, p, expected",
    [
        (1 / 2 * 4 * np.pi, 2, "10"),
        (1 / 2 * 4 * np.pi, 3, "100"),
        ((1 / 2 + 1 / 8 + 1 / 16 + 1 / 32) * 4 * np.pi, 2, "11"),
        ((1 / 2 + 1 / 8 + 1 / 16 + 1 / 32) * 4 * np.pi, 3, "110"),
        ((1 / 2 + 1 / 8 + 1 / 16 + 1 / 32) * 4 * np.pi, 5, "10111"),
    ],
)
def test_binary_repr_int(phi, expected, p):
    """Test that the binary representation or approximation of the angle is correct"""

    assert expected == _binary_repr_int(phi, p)


@pytest.mark.parametrize("p", [2, 3, 4])
def test_units_select_pauli_rot_phase_gradient(p):
    """Test the operators generated by _select_pauli_rot_phase_gradient"""

    phis = [
        (1 / 2 + 1 / 4 + 1 / 8) * 2 * np.pi,
        (1 / 2 + 1 / 4 + 0 / 8) * 2 * np.pi,
        (1 / 2 + 0 / 4 + 1 / 8) * 2 * np.pi,
        (0 / 2 + 1 / 4 + 1 / 8) * 2 * np.pi,
    ]

    wire = "targ"
    control_wires = qp.wires.Wires([f"control_{i}" for i in range(2)])
    angle_wires = qp.wires.Wires([f"aux_{i}" for i in range(p)])
    phase_grad_wires = qp.wires.Wires([f"qft_{i}" for i in range(p)])
    work_wires = qp.wires.Wires([f"work_{i}" for i in range(p - 1)])

    op = _select_pauli_rot_phase_gradient(
        phis,
        control_wires=control_wires,
        target_wire=wire,
        angle_wires=angle_wires,
        phase_grad_wires=phase_grad_wires,
        work_wires=work_wires,
    )

    assert op.name == "ChangeOpBasis"

    # It iterates the ops in reverse order
    for g, exp_name in zip(op, ["Adjoint(Prod)", "SemiAdder", "Prod"], strict=True):
        assert g.name == exp_name

    for g, exp_name in zip(
        op.hyperparameters["operands"][-1], ["MultiControlledX"] * p + ["QROM"], strict=True
    ):
        assert g.name == exp_name


def test_wire_validation():
    """Test that an error is raised when phg wires are fewer than angle wires"""

    circ = qp.tape.QuantumScript([qp.SelectPauliRot([0.2, -0.4], [0], 1)])

    angle_wires = qp.wires.Wires([f"angle_{i}" for i in range(3)])
    phase_grad_wires = qp.wires.Wires([f"phg_{i}" for i in range(2)])
    work_wires = qp.wires.Wires([f"work_{i}" for i in range(2)])

    with pytest.raises(
        ValueError, match="phase_grad_wires needs to be at least as large as angle_wires"
    ):
        _ = select_pauli_rot_phase_gradient(
            circ,
            angle_wires=angle_wires,
            phase_grad_wires=phase_grad_wires,
            work_wires=work_wires,
        )

    with pytest.raises(
        ValueError, match="work_wires needs to be at least as large as angle_wires - 1"
    ):
        _ = select_pauli_rot_phase_gradient(
            circ,
            angle_wires=angle_wires[:2],
            phase_grad_wires=phase_grad_wires,
            work_wires=[],
        )


@pytest.mark.parametrize(
    "phis",
    [
        [
            (1 + 1 / 2 + 1 / 4 + 1 / 8) * 2 * np.pi,
            (8 - 1 / 2 + 1 / 4 + 0 / 8) * 2 * np.pi,
            (1 + 1 / 2 + 0 / 4 + 1 / 8) * 2 * np.pi,
            (-0 / 2 + 1 / 4 + 1 / 8) * 2 * np.pi,
        ],
        [
            (2 + 1 / 2 + 1 / 4 + 1 / 8) * 2 * np.pi,
            (4 - 8 - 1 / 2 + 1 / 4 + 0 / 8) * 2 * np.pi,
            (1 + 1 / 2 + 1 / 4 + 1 / 8) * 2 * np.pi,
            (-1 - 0 / 2 + 1 / 4 + 1 / 8) * 2 * np.pi,
        ],
        [
            (12 + 1 / 2 + 1 / 4 + 0 / 8) * 2 * np.pi,
            (-8 - 1 / 2 + 0 / 4 + 0 / 8) * 2 * np.pi,
            (1 + 1 / 2 + 0 / 4 + 1 / 8) * 2 * np.pi,
            (-1 - 1 / 2 + 1 / 4 + 1 / 8) * 2 * np.pi,
        ],
    ],
)
@pytest.mark.parametrize("rot_axis", ["Z", "X", "Y"])
def test_correctness_select_pauli_rot_phase_gradient(phis, rot_axis):
    """Test that decomposition produce the correct solution"""

    precision = 4
    wire = "targ"
    angle_wires = [f"ang_{i}" for i in range(precision)]
    phase_grad_wires = [f"phg_{i}" for i in range(precision)]
    work_wires = [f"work_{i}" for i in range(precision - 1)]

    @partial(
        select_pauli_rot_phase_gradient,
        angle_wires=angle_wires,
        phase_grad_wires=phase_grad_wires,
        work_wires=work_wires,
    )
    @qp.qnode(qp.device("default.qubit"))
    def select_pauli_rot_circ(phis, control_wires, target_wire):
        prepare_phase_gradient(phase_grad_wires)  # prepare phase gradient state

        for wire in control_wires:
            qp.Hadamard(wire)

        qp.SelectPauliRot(phis, control_wires, target_wire, rot_axis=rot_axis)

        if rot_axis == "Y":
            qp.adjoint(qp.S)(target_wire)

        if rot_axis in ["X", "Y"]:
            qp.Hadamard(target_wire)

        qp.Select([qp.RZ(-phi, target_wire) for phi in phis], control=control_wires)

        if rot_axis in ["X", "Y"]:
            qp.Hadamard(target_wire)

        if rot_axis == "Y":
            qp.S(target_wire)

        for wire in control_wires:
            qp.Hadamard(wire)

        return qp.probs([target_wire] + control_wires + angle_wires)

    # pylint: disable=unsubscriptable-object
    expected_probs = select_pauli_rot_circ(phis, control_wires=[0, 1], target_wire=wire)
    assert np.allclose(expected_probs[0], 1)
