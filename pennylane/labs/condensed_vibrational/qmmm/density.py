# Copyright 2018-2024 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
This module contains utilities for generating liquid densities using packmol.
It provides functionality to convert XYZ molecular coordinates to PDB format
and use packmol to create liquid systems with appropriate densities.
"""

import os
import shutil
import subprocess
import sys
import tempfile
from typing import Optional, Union, Dict, Any
import warnings

import numpy as np

# Import commonly used molecular handling libraries
try:
    from rdkit import Chem
    from rdkit.Chem import AllChem
    from rdkit.Geometry import Point3D
    RDKIT_AVAILABLE = True
except ImportError:
    RDKIT_AVAILABLE = False
    warnings.warn("RDKit not available. Some functionality may be limited.")


# Atomic masses (in atomic mass units) for common elements
ATOMIC_MASSES = {
    'H': 1.008, 'C': 12.011, 'N': 14.007, 'O': 15.999, 'F': 18.998,
    'P': 30.974, 'S': 32.06, 'Cl': 35.45, 'Br': 79.904, 'I': 126.90
}

# Default force field paths (commonly available)
DEFAULT_FORCEFIELDS = {
    'amber': ['amber14-all.xml', 'amber14/tip3pfb.xml'],
    'charmm': ['charmm36.xml', 'charmm36/water.xml'],
    'openff': 'openff-2.1.0'  # This would need special handling
}

# Empirical liquid densities at room temperature (g/cm³)
# These are rough estimates and should ideally be calculated or looked up
EMPIRICAL_DENSITIES = {
    'water': 1.0,
    'ethanol': 0.789,
    'methanol': 0.791,
    'acetone': 0.784,
    'benzene': 0.876,
    'chloroform': 1.489,
    'dimethylsulfoxide': 1.092
}


def xyz_to_pdb(xyz_file: str, output_pdb: Optional[str] = None) -> str:
    """
    Convert an XYZ file to PDB format compatible with packmol.
    
    Parameters
    ----------
    xyz_file : str
        Path to the input XYZ file containing molecular coordinates
    output_pdb : str, optional
        Path for the output PDB file. If None, creates a temporary file
        
    Returns
    -------
    str
        Path to the generated PDB file
        
    Raises
    ------
    FileNotFoundError
        If the input XYZ file doesn't exist
    ValueError
        If the XYZ file format is invalid
    """
    if not os.path.exists(xyz_file):
        raise FileNotFoundError(f"XYZ file not found: {xyz_file}")
    
    # Read XYZ file
    with open(xyz_file, 'r') as f:
        lines = f.readlines()
    
    if len(lines) < 3:
        raise ValueError("Invalid XYZ file format: too few lines")
    
    try:
        n_atoms = int(lines[0].strip())
    except ValueError:
        raise ValueError("Invalid XYZ file format: first line must be number of atoms")
    
    if len(lines) < n_atoms + 2:
        raise ValueError(f"Invalid XYZ file format: expected {n_atoms + 2} lines, got {len(lines)}")
    
    # Parse coordinates
    atoms = []
    for i in range(2, 2 + n_atoms):
        parts = lines[i].strip().split()
        if len(parts) < 4:
            raise ValueError(f"Invalid coordinate line {i}: {lines[i].strip()}")
        
        element = parts[0]
        try:
            x, y, z = float(parts[1]), float(parts[2]), float(parts[3])
        except ValueError:
            raise ValueError(f"Invalid coordinates in line {i}: {lines[i].strip()}")
        
        atoms.append((element, x, y, z))
    
    # Generate output filename if not provided
    if output_pdb is None:
        base_name = os.path.splitext(os.path.basename(xyz_file))[0]
        output_pdb = f"{base_name}.pdb"
    
    # Write PDB file
    _write_pdb_file(atoms, output_pdb)
    
    return output_pdb


def _write_pdb_file(atoms: list, output_pdb: str):
    """
    Write atom coordinates to a PDB file.
    
    Parameters
    ----------
    atoms : list
        List of tuples (element, x, y, z) with atomic coordinates
    output_pdb : str
        Path to the output PDB file
    """
    with open(output_pdb, 'w') as f:
        f.write("REMARK   Generated by PennyLane QML density generator\n")
        
        for i, (element, x, y, z) in enumerate(atoms, 1):
            # PDB ATOM format (fixed width columns):
            # ATOM   serial atom  res seq    x       y       z    occ  temp element
            f.write(f"ATOM  {i:5d}  {element:<4s} MOL A   1    "
                   f"{x:8.3f}{y:8.3f}{z:8.3f}  1.00  0.00           {element:>2s}\n")
        
        f.write("END\n")


def estimate_molecular_size(atoms: list) -> float:
    """
    Estimate the maximum dimension of a molecule from its atomic coordinates.
    
    Parameters
    ----------
    atoms : list
        List of tuples (element, x, y, z) with atomic coordinates
        
    Returns
    -------
    float
        Estimated maximum molecular dimension in Angstroms
    """
    if not atoms:
        return 0.0
    
    coords = np.array([(x, y, z) for _, x, y, z in atoms])
    
    # Calculate the range in each dimension
    ranges = np.max(coords, axis=0) - np.min(coords, axis=0)
    
    # Return the maximum dimension plus some buffer for Van der Waals radii
    return np.max(ranges) + 4.0  # Add ~4 Å for VdW radii


def estimate_molecular_mass(atoms: list) -> float:
    """
    Estimate molecular mass from atomic composition.
    
    Parameters
    ----------
    atoms : list
        List of tuples (element, x, y, z) with atomic coordinates
        
    Returns
    -------
    float
        Estimated molecular mass in atomic mass units (amu)
    """
    total_mass = 0.0
    for element, _, _, _ in atoms:
        if element in ATOMIC_MASSES:
            total_mass += ATOMIC_MASSES[element]
        else:
            warnings.warn(f"Unknown element {element}, using mass of 12.0 amu")
            total_mass += 12.0
    
    return total_mass


def estimate_density(temperature: float = 298.15, pressure: float = 1.0, 
                    molecular_mass: Optional[float] = None, 
                    molecule_name: Optional[str] = None) -> float:
    """
    Estimate liquid density based on temperature, pressure, and molecular properties.
    
    Parameters
    ----------
    temperature : float, default=298.15
        Temperature in Kelvin
    pressure : float, default=1.0
        Pressure in bar
    molecular_mass : float, optional
        Molecular mass in amu
    molecule_name : str, optional
        Name of the molecule for empirical lookup
        
    Returns
    -------
    float
        Estimated density in g/cm³
    """
    # First try empirical lookup
    if molecule_name and molecule_name.lower() in EMPIRICAL_DENSITIES:
        base_density = EMPIRICAL_DENSITIES[molecule_name.lower()]
    else:
        # Use a simple heuristic based on molecular mass
        if molecular_mass is None:
            base_density = 1.0  # Default water-like density
        else:
            # Very rough correlation: heavier molecules tend to be denser
            base_density = 0.5 + 0.02 * molecular_mass  # Rough empirical formula
            base_density = min(base_density, 2.0)  # Cap at reasonable maximum
    
    # Simple temperature and pressure corrections
    # These are very approximate and should be replaced with better models
    temp_correction = 1.0 - 0.001 * (temperature - 298.15)  # Thermal expansion
    pressure_correction = 1.0 + 0.0001 * (pressure - 1.0)  # Compressibility
    
    return base_density * temp_correction * pressure_correction


def generate_packmol_input(solute_pdb: str, n_molecules: int, box_size: float, 
                          output_pdb: str, tolerance: float = 2.0) -> str:
    """
    Generate a packmol input file content for creating a liquid system.
    
    Parameters
    ----------
    solute_pdb : str
        Path to the PDB file of a single molecule
    n_molecules : int
        Number of molecules to pack
    box_size : float
        Size of the cubic box in Angstroms
    output_pdb : str
        Path for the output packed PDB file
    tolerance : float, default=2.0
        Packmol tolerance parameter
        
    Returns
    -------
    str
        Content of the packmol input file
    """
    # Use relative paths and ensure proper formatting
    input_content = f"""tolerance {tolerance:.1f}
filetype pdb
output {os.path.basename(output_pdb)}
seed 1

structure {os.path.basename(solute_pdb)}
  number {n_molecules}
  inside cube 0.0 0.0 0.0 {box_size:.2f}
end structure
"""
    return input_content


def generate_liquid_density(xyz_file: str, 
                           temperature: float = 298.15,
                           pressure: float = 1.0,
                           n_molecules: int = 256,
                           box_size: Optional[float] = None,
                           forcefield_xml: Optional[Union[str, list]] = None,
                           output_dir: Optional[str] = None,
                           cleanup: bool = True) -> Dict[str, Any]:
    """
    Generate a liquid system with appropriate density from an equilibrium XYZ file.
    
    This function takes a molecule in XYZ format and uses packmol to create a liquid
    system with the specified number of molecules at the given temperature and pressure.
    
    Parameters
    ----------
    xyz_file : str
        Path to the XYZ file containing the equilibrium molecular structure
    temperature : float, default=298.15
        Temperature in Kelvin
    pressure : float, default=1.0 
        Pressure in bar
    n_molecules : int, default=256
        Number of molecules to include in the liquid system
    box_size : float, optional
        Size of the cubic simulation box in Angstroms. If None, estimated from density
    forcefield_xml : str or list, optional
        Path(s) to force field XML file(s). If None, uses amber default
    output_dir : str, optional
        Directory for output files. If None, creates a temporary directory
    cleanup : bool, default=True
        Whether to clean up intermediate files
        
    Returns
    -------
    dict
        Dictionary containing:
        - 'pdb_file': Path to the generated PDB file with packed molecules
        - 'density': Estimated/used density in g/cm³
        - 'box_size': Box size in Angstroms
        - 'n_molecules': Number of molecules
        - 'molecular_mass': Molecular mass in amu
        - 'forcefield': Force field information
        
    Raises
    ------
    RuntimeError
        If packmol is not available or fails to run
    FileNotFoundError
        If input files are not found
    """
    # Validate packmol availability
    if not shutil.which("packmol"):
        raise RuntimeError("packmol executable not found in PATH. Please install packmol.")
    
    # Setup output directory
    if output_dir is None:
        output_dir = tempfile.mkdtemp(prefix="qml_density_")
    else:
        os.makedirs(output_dir, exist_ok=True)
    
    try:
        # Convert XYZ to PDB
        print(f"Converting {xyz_file} to PDB format...")
        pdb_file = os.path.join(output_dir, "molecule.pdb")
        xyz_to_pdb(xyz_file, pdb_file)
        
        # Parse atoms for mass calculation
        with open(xyz_file, 'r') as f:
            lines = f.readlines()
        n_atoms = int(lines[0].strip())
        atoms = []
        for i in range(2, 2 + n_atoms):
            parts = lines[i].strip().split()
            atoms.append((parts[0], float(parts[1]), float(parts[2]), float(parts[3])))
        
        # Calculate molecular mass and size
        molecular_mass = estimate_molecular_mass(atoms)
        molecular_size = estimate_molecular_size(atoms)
        print(f"Estimated molecular mass: {molecular_mass:.2f} amu")
        print(f"Estimated molecular size: {molecular_size:.2f} Å")
        
        # Estimate density
        density = estimate_density(temperature, pressure, molecular_mass)
        print(f"Estimated liquid density: {density:.3f} g/cm³")
        
        # Calculate box size if not provided
        if box_size is None:
            # Simple calculation to avoid unit formatting issues
            # Calculate volume needed for target density
            # molecular_mass in amu, density in g/cm³
            total_mass_grams = n_molecules * molecular_mass * 1.66054e-24  # Convert amu to grams
            volume_cm3 = total_mass_grams / density
            box_size_cm = volume_cm3 ** (1/3)
            box_size = box_size_cm * 1e8 * 1.2  # Convert to Angstroms and add 20% buffer
        
        # Validate box size vs molecular size
        min_box_size = molecular_size * 3  # Minimum reasonable box size
        if box_size < min_box_size:
            print(f"Warning: Box size {box_size:.2f} Å may be too small for molecule size {molecular_size:.2f} Å")
            print(f"Adjusting box size to {min_box_size:.2f} Å")
            box_size = min_box_size
        
        print(f"Using box size: {box_size:.2f} Å")
        
        # Generate packmol input
        packed_pdb = os.path.join(output_dir, "packed_system.pdb")
        packmol_input = generate_packmol_input(pdb_file, n_molecules, box_size, packed_pdb)
        
        # Write packmol input file
        packmol_inp = os.path.join(output_dir, "packmol.inp")
        with open(packmol_inp, 'w') as f:
            f.write(packmol_input)
        
        print(f"Generated packmol input file: {packmol_inp}")
        print(f"Box size: {box_size:.2f} Å")
        print(f"Molecule file: {os.path.basename(pdb_file)}")
        
        # Run packmol
        print(f"Running packmol to pack {n_molecules} molecules...")
        try:
            # Packmol needs to read from a file, not stdin
            result = subprocess.run(
                ["packmol", "<", "packmol.inp"],
                shell=True,  # Need shell=True for redirection
                cwd=output_dir,
                check=True, 
                capture_output=True, 
                text=True
            )
            print("Packmol completed successfully!")
            if result.stdout:
                print("Packmol output:", result.stdout[-500:])  # Show last 500 chars
        except subprocess.CalledProcessError as e:
            print(f"Packmol stdout: {e.stdout}")
            print(f"Packmol stderr: {e.stderr}")
            print(f"Packmol input file contents:\n{packmol_input}")
            # Check if output file was created despite error
            if os.path.exists(os.path.join(output_dir, os.path.basename(packed_pdb))):
                print("Note: Output file was created despite error - packmol may have succeeded")
            else:
                raise RuntimeError(f"Packmol failed with return code {e.returncode}. "
                                 f"Common causes: box too small, molecules too large, or invalid PDB format.")
        
        # Prepare force field information
        if forcefield_xml is None:
            forcefield_info = {'type': 'amber', 'files': DEFAULT_FORCEFIELDS['amber']}
        elif isinstance(forcefield_xml, str):
            forcefield_info = {'type': 'custom', 'files': [forcefield_xml]}
        else:
            forcefield_info = {'type': 'custom', 'files': forcefield_xml}
        
        # Prepare return information
        result_info = {
            'pdb_file': packed_pdb,
            'density': density,
            'box_size': box_size,
            'n_molecules': n_molecules,
            'molecular_mass': molecular_mass,
            'forcefield': forcefield_info,
            'output_dir': output_dir
        }
        
        # Cleanup intermediate files if requested
        if cleanup:
            for file_to_remove in [pdb_file, packmol_inp]:
                if os.path.exists(file_to_remove):
                    os.remove(file_to_remove)
        
        return result_info
        
    except Exception as e:
        # Cleanup on error if in temporary directory
        if cleanup and output_dir.startswith(tempfile.gettempdir()):
            shutil.rmtree(output_dir, ignore_errors=True)
        raise e


def main():
    """
    Command line interface for the density generation function.
    """
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Generate liquid density system from equilibrium XYZ file using packmol"
    )
    parser.add_argument("xyz_file", help="Input XYZ file with equilibrium molecular structure")
    parser.add_argument("-t", "--temperature", type=float, default=298.15, 
                       help="Temperature in Kelvin (default: 298.15)")
    parser.add_argument("-p", "--pressure", type=float, default=1.0,
                       help="Pressure in bar (default: 1.0)")
    parser.add_argument("-n", "--n_molecules", type=int, default=256,
                       help="Number of molecules (default: 256)")
    parser.add_argument("-b", "--box_size", type=float, default=None,
                       help="Box size in Angstroms (default: auto-calculated)")
    parser.add_argument("-f", "--forcefield", type=str, default=None,
                       help="Force field XML file path (default: amber)")
    parser.add_argument("-o", "--output_dir", type=str, default=None,
                       help="Output directory (default: temporary)")
    parser.add_argument("--no-cleanup", action="store_true",
                       help="Keep intermediate files")
    
    args = parser.parse_args()
    
    try:
        result = generate_liquid_density(
            xyz_file=args.xyz_file,
            temperature=args.temperature,
            pressure=args.pressure,
            n_molecules=args.n_molecules,
            box_size=args.box_size,
            forcefield_xml=args.forcefield,
            output_dir=args.output_dir,
            cleanup=not args.no_cleanup
        )
        
        print("\n" + "="*50)
        print("DENSITY GENERATION COMPLETED SUCCESSFULLY!")
        print("="*50)
        print(f"Output PDB file: {result['pdb_file']}")
        print(f"Density: {result['density']:.3f} g/cm³")
        print(f"Box size: {result['box_size']:.2f} Å")
        print(f"Number of molecules: {result['n_molecules']}")
        print(f"Molecular mass: {result['molecular_mass']:.2f} amu")
        print(f"Force field: {result['forcefield']['type']}")
        
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
