# Copyright 2025 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
This file contains the definition of the MBQC dialect for the Python compiler.

The MBQC dialect is a set of operations and types used to represent MBQC computations
in the xDSL framework.

It was initially generated by xDSL (using the ``xdsl-tblgen`` tool)
starting from the catalyst/mlir/include/MBQC/IR/MBQCOps.td file in the catalyst repository.
"""

# pylint: disable=too-few-public-methods

# pragma: no cover
from typing import Sequence, TypeAlias

from xdsl.dialects.builtin import AnyAttr, BaseAttr, Float64Type, IntegerAttr, IntegerType
from xdsl.ir import Dialect, Operation, ParametrizedAttribute, SSAValue
from xdsl.irdl import (
    EqAttrConstraint,
    IRDLOperation,
    irdl_attr_definition,
    irdl_op_definition,
    operand_def,
    opt_prop_def,
    prop_def,
    result_def,
)
from xdsl.utils.exceptions import VerifyException

from pennylane.compiler.python_compiler.quantum_dialect import QubitType

QubitSSAValue: TypeAlias = SSAValue[QubitType]


@irdl_attr_definition
class MeasurementPlaneAttr(ParametrizedAttribute):
    """Planes in the Bloch sphere representation with support for arbitrary-basis measurements"""

    name = "mbqc.measurement_plane"


@irdl_op_definition
class MeasureInBasisOp(IRDLOperation):
    """A parametric single-qubit projective measurement in an arbitrary basis."""

    name = "mbqc.measure_in_basis"

    assembly_format = """
        `[` $plane `,` $angle `]` $in_qubit (`postselect` $postselect^)? attr-dict `:` type(results)
    """

    in_qubit = operand_def(QubitType())

    plane = prop_def(BaseAttr(MeasurementPlaneAttr))

    angle = operand_def(EqAttrConstraint(Float64Type()))

    postselect = opt_prop_def(AnyAttr())

    mres = result_def(EqAttrConstraint(IntegerType(1)))

    out_qubit = result_def(QubitType())

    def __init__(
        self, in_qubit: QubitSSAValue | Operation, plane: , angle: , postselect: int | IntegerAttr | None = None
    ):
        if isinstance(postselect, int):
            postselect = IntegerAttr.from_int_and_width(postselect, 32)

        if postselect is None:
            properties = {}
        else:
            properties = {"postselect": postselect}

        super().__init__(
            operands=(in_qubit, angle), properties=properties, result_types=(IntegerType(1), QubitType())
        )

    def verify_(self):
        """Verify operation when rewriting."""
        if self.postselect is None:
            return

        if self.postselect.value.data not in [0, 1]:  # pylint: disable=no-member
            raise VerifyException("'postselect' must be 0 or 1.")


MBQC_Dialect = Dialect(
    "mbqc",
    [
        MeasureInBasisOp,
    ],
    [
        MeasurementPlaneAttr,
    ],
)
