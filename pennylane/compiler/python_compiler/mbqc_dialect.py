# Copyright 2025 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
This module contains the definition of the MBQC dialect for the Python compiler.

The MBQC dialect is a set of operations and types used to represent measurement-based
quantum-computing instructions in the xDSL framework.

It was initially generated by xDSL (using the ``xdsl-tblgen`` tool) starting from the
catalyst/mlir/include/MBQC/IR/MBQCDialect.td file in the catalyst repository.
"""

from typing import Optional, TypeAlias

from xdsl.dialects.builtin import Float64Type, FloatAttr, IntegerAttr, IntegerType
from xdsl.ir import Dialect, EnumAttribute, Operation, SSAValue
from xdsl.irdl import (
    BaseAttr,
    EqAttrConstraint,
    IRDLOperation,
    irdl_attr_definition,
    irdl_op_definition,
    operand_def,
    opt_prop_def,
    prop_def,
    result_def,
)
from xdsl.utils.exceptions import VerifyException
from xdsl.utils.str_enum import StrEnum  # StrEnum is standard in Python>=3.11

from pennylane.compiler.python_compiler.quantum_dialect import QubitType

QubitSSAValue: TypeAlias = SSAValue[QubitType]


class MeasurementPlaneEnum(StrEnum):
    """Enum containing supported measurement-plane attributes"""

    # pylint: disable=too-few-public-methods

    XY = "XY"
    YZ = "YZ"
    ZX = "ZX"


@irdl_attr_definition
class MeasurementPlaneAttr(EnumAttribute[MeasurementPlaneEnum]):
    """Planes in the Bloch sphere representation with support for arbitrary-basis measurements"""

    # pylint: disable=too-few-public-methods

    name = "mbqc.measurement_plane"


@irdl_op_definition
class MeasureInBasisOp(IRDLOperation):
    """A parametric single-qubit projective measurement in an arbitrary basis."""

    # pylint: disable=too-few-public-methods

    name = "mbqc.measure_in_basis"

    in_qubit = operand_def(BaseAttr(QubitType))

    plane = prop_def(BaseAttr(MeasurementPlaneAttr))

    angle = operand_def(EqAttrConstraint(Float64Type()))

    postselect = opt_prop_def(IntegerType(32))

    mres = result_def(EqAttrConstraint(IntegerType(1)))

    out_qubit = result_def(BaseAttr(QubitType))

    assembly_format = """
            `[` $plane `,` $angle `]` $in_qubit (`postselect` $postselect^)? attr-dict `:` type(results)
        """

    def __init__(
        self,
        in_qubit: QubitSSAValue | Operation,
        plane: MeasurementPlaneAttr,
        angle: SSAValue[Float64Type],
        postselect: Optional[int | IntegerAttr] = None,
    ):
        properties = {"plane": plane}

        if isinstance(postselect, int):
            postselect = IntegerAttr.from_int_and_width(postselect, 32)

        if postselect is not None:
            properties["postselect"] = postselect

        super().__init__(
            operands=(in_qubit, angle),
            properties=properties,
            result_types=(IntegerType(1), QubitType()),
        )

    def verify_(self):
        """Verify operation when rewriting."""
        if self.postselect is None:
            return

        if self.postselect.value.data not in [0, 1]:
            raise VerifyException("'postselect' must be 0 or 1.")


MBQCDialect = Dialect(
    "mbqc",
    [
        MeasureInBasisOp,
    ],
    [
        MeasurementPlaneAttr,
    ],
)
