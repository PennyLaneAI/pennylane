# Copyright 2025 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
This module contains the definition of the MBQC dialect for the Python compiler.

The MBQC dialect is a set of operations and types used to represent measurement-based
quantum-computing instructions in the xDSL framework.

It was initially generated by xDSL (using the ``xdsl-tblgen`` tool) starting from the
catalyst/mlir/include/MBQC/IR/MBQCDialect.td file in the catalyst repository.

For detailed documentation on the operations contained in this dialect, please refer to the MBQC
dialect documentation in Catalyst.
"""

from typing import TypeAlias

from xdsl.dialects.builtin import (
    I32,
    AnyAttr,
    Float64Type,
    IntegerAttr,
    IntegerType,
    MemRefType,
    StringAttr,
    TensorType,
    i1,
)
from xdsl.ir import Dialect, EnumAttribute, Operation, SpacedOpaqueSyntaxAttribute, SSAValue
from xdsl.irdl import (
    IRDLOperation,
    irdl_attr_definition,
    irdl_op_definition,
    operand_def,
    opt_prop_def,
    prop_def,
    result_def,
)
from xdsl.utils.exceptions import VerifyException
from xdsl.utils.str_enum import StrEnum  # StrEnum is standard in Python>=3.11

from ..xdsl_extras import MemRefRankConstraint, TensorRankConstraint
from .quantum import QubitType, QuregType

QubitSSAValue: TypeAlias = SSAValue[QubitType]


class MeasurementPlaneEnum(StrEnum):
    """Enum containing supported measurement-plane attributes"""

    # pylint: disable=too-few-public-methods

    XY = "XY"
    YZ = "YZ"
    ZX = "ZX"


@irdl_attr_definition
class MeasurementPlaneAttr(EnumAttribute[MeasurementPlaneEnum], SpacedOpaqueSyntaxAttribute):
    """Planes in the Bloch sphere representation with support for arbitrary-basis measurements"""

    # pylint: disable=too-few-public-methods

    name = "mbqc.measurement_plane"


@irdl_op_definition
class MeasureInBasisOp(IRDLOperation):
    """A parametric single-qubit projective measurement in an arbitrary basis."""

    # pylint: disable=too-few-public-methods

    name = "mbqc.measure_in_basis"

    assembly_format = """
            `[` $plane `,` $angle `]` $in_qubit (`postselect` $postselect^)? attr-dict `:` type(results)
        """

    in_qubit = operand_def(QubitType)

    plane = prop_def(MeasurementPlaneAttr)

    angle = operand_def(Float64Type())

    postselect = opt_prop_def(IntegerAttr[I32])

    mres = result_def(IntegerType(1))

    out_qubit = result_def(QubitType)

    def __init__(
        self,
        in_qubit: QubitSSAValue | Operation,
        plane: MeasurementPlaneAttr,
        angle: SSAValue[Float64Type],
        postselect: int | IntegerAttr | None = None,
    ):
        properties = {"plane": plane}

        if isinstance(postselect, int):
            postselect = IntegerAttr.from_int_and_width(postselect, 32)

        if postselect is not None:
            properties["postselect"] = postselect

        super().__init__(
            operands=(in_qubit, angle),
            properties=properties,
            result_types=(IntegerType(1), QubitType()),
        )

    def verify_(self):
        """Verify operation when rewriting."""
        if self.postselect is None:
            return

        if self.postselect.value.data not in [0, 1]:
            raise VerifyException("'postselect' must be 0 or 1.")


@irdl_op_definition
class GraphStatePrepOp(IRDLOperation):
    """Allocate resources for a new graph state."""

    # pylint: disable=too-few-public-methods

    name = "mbqc.graph_state_prep"

    assembly_format = """
            `(` $adj_matrix `:` type($adj_matrix) `)` `[` `init` $init_op `,` `entangle` $entangle_op `]` attr-dict `:` type(results)
        """

    adj_matrix = operand_def(
        (TensorType.constr(i1) & TensorRankConstraint(1))
        | (MemRefType.constr(i1) & MemRefRankConstraint(1))
    )

    init_op = prop_def(StringAttr)

    entangle_op = prop_def(StringAttr)

    qreg = result_def(QuregType)

    def __init__(
        self, adj_matrix: AnyAttr, init_op: str | StringAttr, entangle_op: str | StringAttr
    ):
        if isinstance(init_op, str):
            init_op = StringAttr(data=init_op)

        if isinstance(entangle_op, str):
            entangle_op = StringAttr(data=entangle_op)

        properties = {"init_op": init_op, "entangle_op": entangle_op}

        qreg = QuregType()

        super().__init__(
            operands=(adj_matrix,),
            result_types=(qreg,),
            properties=properties,
        )


MBQC = Dialect(
    "mbqc",
    [
        MeasureInBasisOp,
        GraphStatePrepOp,
    ],
    [
        MeasurementPlaneAttr,
    ],
)
