# Copyright 2025 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
This module contains the QEC dialect for the Python compiler.

The QEC dialect is a set of operations and types used to represent quantum error correction
instructions in the xDSL framework.

It was initially generated by xDSL (using the ``xdsl-tblgen`` tool) starting from the
catalyst/mlir/include/QEC/IR/QECDialect.td file in the catalyst repository.
"""

# pylint: disable=too-few-public-methods

from xdsl.dialects.builtin import I16, ArrayAttr, IntegerAttr, IntegerType, StringAttr, i16
from xdsl.dialects.utils import AbstractYieldOperation
from xdsl.ir import Attribute, Dialect, EnumAttribute, SpacedOpaqueSyntaxAttribute
from xdsl.irdl import (
    AttrSizedOperandSegments,
    IRDLOperation,
    irdl_attr_definition,
    irdl_op_definition,
    lazy_traits_def,
    operand_def,
    opt_operand_def,
    opt_prop_def,
    prop_def,
    region_def,
    result_def,
    traits_def,
    var_operand_def,
    var_result_def,
)
from xdsl.traits import HasParent, IsTerminator, Pure, SingleBlockImplicitTerminator
from xdsl.utils.str_enum import StrEnum

from .quantum import QubitType


class LogicalInitKind(StrEnum):
    """The initial state of a logical qubit such as |0⟩, |1⟩, |+⟩, |−⟩, |Y⟩, |-Y⟩, |m⟩, or |m̅⟩."""

    Zero = "zero"  # |0⟩ Non-magic state
    One = "one"  # |1⟩ Non-magic state
    Plus = "plus"  # |+⟩  = (|0⟩ + |1⟩) / sqrt(2)  Non-magic state
    Minus = "minus"  # |-⟩  = (|0⟩ - |1⟩) / sqrt(2)  Non-magic state
    PlusI = "plus_i"  # |Y⟩  = (|0⟩ + i|1⟩) / sqrt(2) Non-magic / Magic state
    MinusI = "minus_i"  # |-Y⟩ = (|0⟩ - i|1⟩) / sqrt(2) Non-magic / Magic state
    Magic = "magic"  # |m⟩  = |0⟩ + e^{iπ/4}|1⟩      Magic state
    MagicConj = "magic_conj"  # |m̅⟩  = |0⟩ + e^{-iπ/4}|1⟩     Magic state


@irdl_attr_definition
class LogicalInit(EnumAttribute[LogicalInitKind], SpacedOpaqueSyntaxAttribute):
    """The initial state of a logical qubit such as |0⟩, |1⟩, |+⟩, |−⟩, |Y⟩, |-Y⟩, |m⟩, or |m̅⟩."""

    name = "qec.enum"


# Type alias for a product of Pauli operators, aka a Pauli word.
PauliWord = ArrayAttr[StringAttr]


@irdl_op_definition
class YieldOp(AbstractYieldOperation[Attribute]):
    """Return results from a layer region"""

    name = "qec.yield"

    traits = lazy_traits_def(lambda: (IsTerminator(), HasParent(LayerOp), Pure()))


@irdl_op_definition
class FabricateOp(IRDLOperation):
    """Fabricate axillary qubits from qubit factories."""

    name = "qec.fabricate"

    assembly_format = """
            $init_state attr-dict `:` type($out_qubits)
        """

    init_state = prop_def(LogicalInit)

    out_qubits = var_result_def(QubitType)


@irdl_op_definition
class LayerOp(IRDLOperation):
    """A layer operation"""

    name = "qec.layer"

    initArgs = var_operand_def()

    results = var_result_def()

    region = region_def("single_block")

    traits = traits_def(SingleBlockImplicitTerminator(YieldOp))

    # TODO: add a custom parse and print for this operation


@irdl_op_definition
class PPMeasurementOp(IRDLOperation):
    """Pauli Product Measurement on qubits."""

    name = "qec.ppm"

    assembly_format = """
          $pauli_product (`(` $rotation_sign^ `)`)? $in_qubits (`cond` `(` $condition^ `)`)? attr-dict `:` type(results)
        """

    irdl_options = [AttrSizedOperandSegments(as_property=True)]

    pauli_product = prop_def(PauliWord)

    rotation_sign = opt_prop_def(IntegerAttr[I16], default_value=IntegerAttr(1, i16))

    in_qubits = var_operand_def(QubitType)

    condition = opt_operand_def(IntegerType(1))

    mres = result_def(IntegerType(1))

    out_qubits = var_result_def(QubitType)


@irdl_op_definition
class PPRotationOp(IRDLOperation):
    """Pauli Product Rotation on qubits."""

    name = "qec.ppr"

    assembly_format = """
          $pauli_product `(` $rotation_kind `)` $in_qubits attr-dict (`cond` `(` $condition^ `)`)? `:` type($out_qubits)
        """

    irdl_options = [AttrSizedOperandSegments(as_property=True)]

    pauli_product = prop_def(PauliWord)

    rotation_kind = prop_def(IntegerAttr[IntegerType(16)])

    in_qubits = var_operand_def(QubitType)

    condition = opt_operand_def(IntegerType(1))

    out_qubits = var_result_def(QubitType)


@irdl_op_definition
class PrepareStateOp(IRDLOperation):
    """Initialize existing qubits into a given state."""

    name = "qec.prepare"

    assembly_format = """
          $init_state $in_qubits attr-dict `:` type($out_qubits)
        """

    init_state = prop_def(LogicalInit)

    in_qubits = var_operand_def(QubitType)

    out_qubits = var_result_def(QubitType)


@irdl_op_definition
class SelectPPMeasurementOp(IRDLOperation):
    """Multiplexed Pauli product measurement."""

    name = "qec.select.ppm"

    assembly_format = """
          `(` $select_switch `,` $pauli_product_0 `,` $pauli_product_1 `)` $in_qubits attr-dict `:` type(results)
        """

    select_switch = operand_def(IntegerType(1))

    pauli_product_0 = prop_def(PauliWord)

    pauli_product_1 = prop_def(PauliWord)

    in_qubits = var_operand_def(QubitType)

    mres = result_def(IntegerType(1))

    out_qubits = var_result_def(QubitType)


QEC = Dialect(
    "qec",
    [
        FabricateOp,
        LayerOp,
        PPMeasurementOp,
        PPRotationOp,
        PrepareStateOp,
        SelectPPMeasurementOp,
        YieldOp,
    ],
    [
        LogicalInit,
    ],
)
