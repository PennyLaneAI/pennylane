# Copyright 2025 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
This file contains the definition of the Quantum dialect for the Python compiler.

The Quantum dialect is a set of operations and types used to represent quantum computations
in the xDSL framework.

It was initially generated by xDSL (using the ``xdsl-tblgen`` tool)
starting from the catalyst/mlir/include/Quantum/IR/QuantumOps.td file in the catalyst repository.
"""

# pylint: disable=too-few-public-methods

# pragma: no cover

from typing import Sequence, TypeAlias

from xdsl.dialects.builtin import (
    I32,
    I64,
    AnyAttr,
    Float64Type,
    FloatAttr,
    IntegerAttr,
    IntegerType,
    StringAttr,
    UnitAttr,
    i64,
)
from xdsl.ir import (
    Block,
    Dialect,
    EnumAttribute,
    Operation,
    ParametrizedAttribute,
    Region,
    SpacedOpaqueSyntaxAttribute,
    SSAValue,
    StrEnum,
    TypeAttribute,
)
from xdsl.irdl import (
    AttrSizedOperandSegments,
    AttrSizedResultSegments,
    IRDLOperation,
    irdl_attr_definition,
    irdl_op_definition,
    operand_def,
    opt_operand_def,
    opt_prop_def,
    opt_result_def,
    prop_def,
    region_def,
    result_def,
    var_operand_def,
    var_result_def,
)
from xdsl.utils.exceptions import VerifyException

################################################################
######################## ATTRIBUTES ############################
################################################################


@irdl_attr_definition
class ObservableType(ParametrizedAttribute, TypeAttribute):
    """A quantum observable for use in measurements.

    Operations that may return an observable are:
    * quantum.compbasis
    * quantum.hamiltonian
    * quantum.hermitian
    * quantum.named_observable
    """

    name = "quantum.obs"


@irdl_attr_definition
class QubitType(ParametrizedAttribute, TypeAttribute):
    """A value-semantic qubit (state)."""

    name = "quantum.bit"


@irdl_attr_definition
class QuregType(ParametrizedAttribute, TypeAttribute):
    """An array of value-semantic qubits (i.e. quantum register)."""

    name = "quantum.reg"


@irdl_attr_definition
class ResultType(ParametrizedAttribute, TypeAttribute):
    """A quantum measurement result.

    This is unused but define in Catalyst. May be scheduled for deletion.
    """

    name = "quantum.res"


class NamedObservable(StrEnum):
    """Known named observables"""

    Identity = "Identity"
    PauliX = "PauliX"
    PauliY = "PauliY"
    PauliZ = "PauliZ"
    Hadamard = "Hadamard"


@irdl_attr_definition
class NamedObservableAttr(EnumAttribute[NamedObservable], SpacedOpaqueSyntaxAttribute):
    """Known named observables"""

    name = "quantum.named_observable"


################################################################
######################## OPERATIONS ############################
################################################################


QubitSSAValue: TypeAlias = SSAValue[QubitType]
QuregSSAValue: TypeAlias = SSAValue[QuregType]
ObservableSSAValue: TypeAlias = SSAValue[ObservableType]


@irdl_op_definition
class AdjointOp(IRDLOperation):
    """Calculate the adjoint of the enclosed operations.

    This operation takes as an input a quantum register and outputs
    an updated quantum register. Its body may contain arbitrary
    quantum operations, including nested adjoint operations.

    Args:
        qreg (QuregSSAValue | Operation): input quantum register. If it is an operation
            then this operation must return a single value
            and that value must be a quantum register.
        region: operations that will be adjointed.

    **Example**

    The PennyLane operations

    .. code-block:: python

        qml.adjoint(qml.Hadamard(0))

    are equivalent to

    .. code-block:: mlir

        %register_0 = quantum.alloc(1) : !quantum.reg
        %register_3 = quantum.adjoint(%register_0) {

        ^bb0(%register_1: !quantum.reg):
          %qubit_0 = quantum.extract %register_1[0] : !quantum.bit
          %qubit_1 = quantum.custom "Hadamard"() %qubit_0 : !quantum.bit
          %qubit_2 = quantum.custom "S"() %qubit_1 : !quantum.bit
          %register_2 = quantum.insert %register_1[0], %qubit_2 : !quantum.reg, !quantum.bit
          quantum.yield %register_2
        }

    When the transformation `--adjoint-lowering` is applied, then the adjoint

    .. code-block:: mlir

        %register_0 = quantum.alloc(1) : !quantum.reg
        %qubit_0 = quantum.extract %arg0[0] : !quantum.bit

        // Notice that the order has been reversed.
                      // notice the adj attribute V
        %qubit_1 = quantum.custom "S"() %qubit_0 adj : !quantum.bit
                             // notice the adj attribute V
        %qubit_2 = quantum.custom "Hadamard"() %qubit_1 adj : !quantum.bit

        %register_1 = quantum.insert %original_register[0], %qubit_2 : !quantum.reg, !quantum.bit

    """

    name = "quantum.adjoint"

    assembly_format = """
        `(` $qreg `)` attr-dict `:` type(operands) $region
    """

    qreg = operand_def(QuregType)

    out_qreg = result_def(QuregType)

    region = region_def("single_block")

    def __init__(
        self,
        qreg: QuregSSAValue | Operation,
        region: Region | Sequence[Operation] | Sequence[Block],
    ):
        super().__init__(operands=(qreg,), result_types=(QuregType(),), regions=(region,))


@irdl_op_definition
class AllocOp(IRDLOperation):
    """Allocate n qubits into a quantum register.

    Args:
        nqubits (int | IntegerAttr | SSAValue): Quantity of wires/qubits in the state vector.
            If the value for `nqubits` is either an Python integer
            or an IntegerAttr, then the number is known at compile time.
            If it is an SSAValue, then it is likely that this value is
            computed at runtime.

    """

    name = "quantum.alloc"

    # TODO: https://github.com/xdslproject/xdsl/pull/4295
    # assembly_format = """
    #        `(` ($nqubits^):($nqubits_attr)? `)` attr-dict `:` type(results)
    #    """

    nqubits = opt_operand_def(i64)

    nqubits_attr = opt_prop_def(IntegerAttr[I64])

    qreg = result_def(QuregType)

    def __init__(self, nqubits: int | IntegerAttr | SSAValue):
        if isinstance(nqubits, int):
            nqubits = IntegerAttr.from_int_and_width(nqubits, 64)

        if isinstance(nqubits, IntegerAttr):
            operands = (None,)
            properties = {"nqubits_attr": nqubits}
        else:
            operands = (nqubits,)
            properties = {}

        super().__init__(operands=operands, properties=properties, result_types=(QuregType(),))

    def verify_(self):
        """Verify operation when rewriting."""
        if self.nqubits_attr is None:
            return

        if self.nqubits_attr.value.data < 0:  # pylint: disable=no-member
            raise VerifyException("Cannot allocate less than zero qubits.")


@irdl_op_definition
class ComputationalBasisOp(IRDLOperation):
    """Define a pseudo-obeservable of the computational basis for use in measurements.

    Args:
        qubits (Sequence[SSAValue] | None): Qubits that make up the computational basis.
        qreg: (SSAValue | None): Quantum register that makes up the computational basis.

    .. note::

        Either qubits or qreg must be supplied.

    """

    name = "quantum.compbasis"

    assembly_format = """
        (`qubits` $qubits^)? (`qreg` $qreg^)? attr-dict `:` type(results)
    """

    irdl_options = [AttrSizedOperandSegments(as_property=True)]

    qubits = var_operand_def(QubitType)

    qreg = opt_operand_def(QuregType)

    obs = result_def(ObservableType)

    # TODO: Add init to validate qubit or qreg was supplied


@irdl_op_definition
class CountsOp(IRDLOperation):
    """Compute sample counts for the given observable for the current state.

    The `quantum.counts` operation represents the measurement process of sampling eigenvalues
    from an observable on the current quantum state and counting the frequency of each
    eigenvalue.

    Args:
        obs (Observable): The only SSA argument is an observable that must be defined by an
            operation in the local scope. from an observable on the current quantum state.
            The number of samples to draw is determined by the device shots argument in the device
            initialization operation in the local scope.

    Returns:
        eigvals: An array for the eigenvalues. These are the possible bitstrings one could measure
            on the given qubits, encoded as (floating-point) integers.
        counts: An array counting each eigenvalue.

    .. note::

        in_eigvals and in_counts will in general not be required when working
        with xDSL. This is due to an implementation detail in Catalyst.
        These inputs correspond to the input memory that will hold the output
        eigvals and counts.

    **Example**

    .. code-block:: mlir

        func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit, %shots: i64)
        {
            quantum.device shots(%shots) ["rtd_lightning.so", "lightning.qubit", "{my_attr: my_attr_value}"]
            %obs = quantum.compbasis %q0, %q1 : !quantum.obs

            // Notice two tensors with a single dimension being returned.
            %counts = quantum.counts %obs : tensor<4xf64>, tensor<4xi64>

            %obs2 = quantum.pauli %q0[3], %q1[1] : !quantum.obs
            %counts2 = quantum.counts %obs2 : tensor<2xf64>, tensor<2xi64>

            func.return
        }

    """

    name = "quantum.counts"

    assembly_format = """
        $obs ( `shape` $dynamic_shape^ )?
        ( `in` `(` $in_eigvals^ `:` type($in_eigvals) `,` $in_counts `:` type($in_counts) `)` )?
        attr-dict ( `:` type($eigvals)^ `,` type($counts) )?
    """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    obs = operand_def(ObservableType)

    dynamic_shape = opt_operand_def(IntegerType(64))

    in_eigvals = opt_operand_def(AnyAttr())

    in_counts = opt_operand_def(AnyAttr())

    eigvals = opt_result_def(AnyAttr())

    counts = opt_result_def(AnyAttr())


@irdl_op_definition
class CustomOp(IRDLOperation):
    """A generic quantum gate on n qubits with m floating point parameters.

    This operation represents an quantum operation acting on wires.
    This operation may be adjointed, or may be controlled.

    Args:
        name (string | StringAttr): The operation's name. E.g., Hadamard.
        params (Sequence[SSAValue]): The classical parameters.
        in_qubits (Sequence[SSAValue]): The qubits the operation acts on.
        adjoint (UnitAttr | bool | None): Denotes whether the operation is adjointed.
            If a UnitAttr or True value is passed, then the operation is adjointed.
        in_ctrl_qubits (Sequence[SSAValue]): Control qubits.
        in_ctrl_values (Sequence[SSAValue | bool]): Control values. Must be True or False.

    Returns:
        out_qubits (Sequence[SSAValue]): The output qubits.
        out_ctrl_qubits (Sequence[SSAVAlue]): The output control qubits.

    .. note::

        We say that an operation is "controlled" if it has in_ctrl_qubits. Therefore a CNOT
        operation is not controlled in this context.

        The same number of in_ctrl_qubits and in_ctrl_values are required.

        The semantics of these gates are given by the runtime.

    **Example**

    .. code-block:: mlir

        %out_qubit = quantum.custom "RX"(%param) %in_qubit

    """

    name = "quantum.custom"

    assembly_format = """
        $gate_name `(` $params `)` $in_qubits
        (`adj` $adjoint^)?
        attr-dict
        ( `ctrls` `(` $in_ctrl_qubits^ `)` )?
        ( `ctrlvals` `(` $in_ctrl_values^ `)` )?
        `:` type($out_qubits) (`ctrls` type($out_ctrl_qubits)^ )?
    """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    params = var_operand_def(Float64Type())

    in_qubits = var_operand_def(QubitType)

    gate_name = prop_def(StringAttr)

    adjoint = opt_prop_def(UnitAttr)

    in_ctrl_qubits = var_operand_def(QubitType)

    in_ctrl_values = var_operand_def(IntegerType(1))

    out_qubits = var_result_def(QubitType)

    out_ctrl_qubits = var_result_def(QubitType)

    # pylint: disable=too-many-arguments
    def __init__(
        self,
        *,
        in_qubits: QubitSSAValue | Operation | Sequence[QubitSSAValue | Operation],
        gate_name: str | StringAttr,
        params: SSAValue[Float64Type] | Sequence[SSAValue[Float64Type]] | None = None,
        in_ctrl_qubits: (
            QubitSSAValue | Operation | Sequence[QubitSSAValue | Operation] | None
        ) = None,
        in_ctrl_values: (
            SSAValue[IntegerType]
            | Operation
            | Sequence[SSAValue[IntegerType]]
            | Sequence[Operation]
            | None
        ) = None,
        adjoint: UnitAttr | bool = False,
    ):
        params = () if params is None else params
        in_ctrl_qubits = () if in_ctrl_qubits is None else in_ctrl_qubits
        in_ctrl_values = () if in_ctrl_values is None else in_ctrl_values

        if not isinstance(params, Sequence):
            params = (params,)
        if not isinstance(in_qubits, Sequence):
            in_qubits = (in_qubits,)
        if not isinstance(in_ctrl_qubits, Sequence):
            in_ctrl_qubits = (in_ctrl_qubits,)
        if not isinstance(in_ctrl_values, Sequence):
            in_ctrl_values = (in_ctrl_values,)

        if isinstance(gate_name, str):
            gate_name = StringAttr(data=gate_name)

        out_qubits = tuple(QubitType() for _ in in_qubits)
        out_ctrl_qubits = tuple(QubitType() for _ in in_ctrl_qubits)
        properties = {"gate_name": gate_name}
        if adjoint:
            properties["adjoint"] = UnitAttr()

        super().__init__(
            operands=(params, in_qubits, in_ctrl_qubits, in_ctrl_values),
            result_types=(out_qubits, out_ctrl_qubits),
            properties=properties,
        )


@irdl_op_definition
class DeallocOp(IRDLOperation):
    """Deallocate a quantum register.

    Args:
        qreg (SSAValue): The quantum register to deallocate
    """

    name = "quantum.dealloc"

    assembly_format = """
        $qreg attr-dict `:` type(operands)
    """

    qreg = operand_def(QuregType)

    def __init__(self, qreg: QuregSSAValue | Operation):
        super().__init__(operands=(qreg,))


@irdl_op_definition
class DeviceInitOp(IRDLOperation):
    """Initialize a quantum device.

    Args:
        shots (SSAValue | None): number of shots requested by the user.
        lib (StringAttr): The location of the shared object that contains the implementation of
            the QuantumDevice interface.
        device_name (StringAttr): Name of the device.
        kwargs (StringAttr): Static input to the device that can be helpful for passing options.
    """

    name = "quantum.device"

    assembly_format = """
        (`shots` `(` $shots^ `)`)? `[` $lib `,` $device_name `,` $kwargs `]` attr-dict
    """

    shots = opt_operand_def(IntegerType(64))

    lib = prop_def(StringAttr)

    device_name = prop_def(StringAttr)

    kwargs = prop_def(StringAttr)


@irdl_op_definition
class DeviceReleaseOp(IRDLOperation):
    """Release the active quantum device.

    Once this operation executes, the quantum device is released back into the pool of available devices.
    For software simulators, valid semantics include resetting the simulator.
    """

    name = "quantum.device_release"

    assembly_format = "attr-dict"


@irdl_op_definition
class ExpvalOp(IRDLOperation):
    """Compute the expectation value of the given observable for the current state.

    The `quantum.expval` operation represents the measurement process of computing the
    expectation value of an observable on the current quantum state. While this quantity can
    be computed analytically on simulators, for hardware execution or shot noise
    simulation, the shots attached to the device
    in the local scope is used.

    Args:
        obs (SSAValue): an observable that must be defined by an operation in the local scope.

    Results:
        expval (f64): The expectation value.


    .. code-block:: mlir

        func.func @foo(%q: !quantum.bit)
        {
            %obs = quantum.namedobs %q[4] : !quantum.obs
            %expval = quantum.expval %obs : f64
            func.return
        }
    """

    name = "quantum.expval"

    assembly_format = "$obs attr-dict `:` type(results)"

    obs = operand_def(ObservableType)

    expval = result_def(Float64Type())

    def __init__(self, obs: ObservableSSAValue | Operation):
        super().__init__(operands=(obs,), result_types=(Float64Type(),))


@irdl_op_definition
class ExtractOp(IRDLOperation):
    """Extract a qubit value from a register.

    Args:
        qreg (SSAValue): The quantum register containing the qubit to be extracted.
        idx (SSAValue | None): An index that may correspond to an unknown wire.
        idx_attr (IntegerAttr | int): An index that is statically known.

    Results:
        qubit: The extracted qubit.
    """

    name = "quantum.extract"

    # assembly_format = """
    #        $qreg `[` ($idx^):($idx_attr)? `]` attr-dict `:` type($qreg) `->` type(results)
    #    """

    qreg = operand_def(QuregType)

    idx = opt_operand_def(IntegerType(64))

    idx_attr = opt_prop_def(AnyAttr())

    qubit = result_def(QubitType)

    def __init__(
        self,
        qreg: QuregSSAValue | Operation,
        idx: int | SSAValue[IntegerType] | Operation | IntegerAttr,
    ):
        if isinstance(idx, int):
            idx = IntegerAttr.from_int_and_width(idx, 64)

        if isinstance(idx, IntegerAttr):
            operands = (qreg, None)
            properties = {"idx_attr": idx}
        else:
            operands = (qreg, idx)
            properties = {}

        super().__init__(
            operands=operands,
            result_types=(QubitType(),),
            properties=properties,
        )


@irdl_op_definition
class FinalizeOp(IRDLOperation):
    """Teardown the quantum runtime.

    Executing this instruction concretely corresponds to executing the
    `__catalyst__rt__finalize` function in the runtime which is expected
    to be the very last thing executed by the library.
    """

    name = "quantum.finalize"

    assembly_format = "attr-dict"


@irdl_op_definition
class GlobalPhaseOp(IRDLOperation):
    """Global Phase.

    Applies global phase to the current system.

    Args:
        params (SSAValue | float): The global phase
        in_ctrl_qubits (SSAValue): The control qubits.
        in_ctrl_values (SSAValue): The control values.

    Results:
        out_ctrl_qubits: The control qubits

    .. note::

        With the introduction of dynamic qubit allocation, applying a global
        phase and then creating a new qubit results in undefined behaviour.
    """

    name = "quantum.gphase"

    assembly_format = """
           `(` $params `)` 
           attr-dict 
           ( `ctrls` `(` $in_ctrl_qubits^ `)` )?  
           ( `ctrlvals` `(` $in_ctrl_values^ `)` )? 
           `:` type(results)
       """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    params = operand_def(Float64Type())

    in_ctrl_qubits = var_operand_def(QubitType)

    in_ctrl_values = var_operand_def(IntegerType(1))

    out_ctrl_qubits = var_result_def(QubitType)

    # pylint: disable=too-many-arguments
    def __init__(
        self,
        *,
        params: float | SSAValue[Float64Type],
        in_ctrl_qubits: (
            QubitSSAValue | Operation | Sequence[QubitSSAValue | Operation] | None
        ) = None,
        in_ctrl_values: (
            SSAValue[IntegerType]
            | Operation
            | Sequence[SSAValue[IntegerType]]
            | Sequence[Operation]
            | None
        ) = None,
    ):
        if isinstance(params, float):
            params = FloatAttr(data=params, type=Float64Type())
        in_ctrl_qubits = () if in_ctrl_qubits is None else in_ctrl_qubits
        in_ctrl_values = () if in_ctrl_values is None else in_ctrl_values

        if not isinstance(in_ctrl_qubits, Sequence):
            in_ctrl_qubits = (in_ctrl_qubits,)
        if not isinstance(in_ctrl_values, Sequence):
            in_ctrl_values = (in_ctrl_values,)

        out_ctrl_qubits = tuple(QubitType() for _ in in_ctrl_qubits)

        super().__init__(
            operands=(params, in_ctrl_qubits, in_ctrl_values),
            result_types=(out_ctrl_qubits,),
        )


@irdl_op_definition
class HamiltonianOp(IRDLOperation):
    """Define a Hamiltonian observable for use in measurements.

    The `quantum.hamiltonian` operation defines a quantum observable to be used by other
    operations such as measurement processes. The specific observable defined here represents
    the hamiltonian of observables. The arguments are a set of coefficients and a set of
    `quantum.Observable` generated by `quantum.namedobs`, `quantum.hermitian`,
    or `quantum.tensorobs`.

    **Example**

    .. code-block:: mlir

        func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit, %c: tensor<2xf64>) {
            %obs1 = quantum.namedobs %q0[4] : !quantum.obs
            %obs2 = quantum.namedobs %q1[2] : !quantum.obs
            %res = quantum.hamiltonian(%c: tensor<2xf64>) %obs1, %obs2 : !quantum.obs
            func.return
        }
    """

    name = "quantum.hamiltonian"

    assembly_format = """
        `(` $coeffs `:` type($coeffs) `)` $terms attr-dict `:` type(results)
    """

    coeffs = operand_def(AnyAttr())

    terms = var_operand_def(ObservableType)

    obs = result_def(ObservableType)


@irdl_op_definition
class HermitianOp(IRDLOperation):
    """Define a Hermitian observable for use in measurements.

    The `quantum.hermitian` operation defines a quantum observable to be used by measurement
    processes. The specific observable defined here represents the Hermitian observable on a
    set of qubits. The arguments are a set of qubits to measure as well as a row-major flatten
    matrix of complex numbers that represents a Hermitian matrix that must be of size
    2^(number of qubits) * 2^(number of qubits).
    """

    name = "quantum.hermitian"

    assembly_format = """
        `(` $matrix `:` type($matrix) `)` $qubits attr-dict `:` type(results)
    """

    matrix = operand_def(AnyAttr())

    qubits = var_operand_def(QubitType)

    obs = result_def(ObservableType)


@irdl_op_definition
class InitializeOp(IRDLOperation):
    """Initialize the quantum runtime.

    The execution of this operation corresponds to the execution of Catalyst's runtime function
    __catalyst__rt__initialize which is the first function that will be called for the duration
    of the whole compiled object.
    """

    name = "quantum.init"

    assembly_format = "attr-dict"


@irdl_op_definition
class InsertOp(IRDLOperation):
    """Update the qubit value of a register.

    Args:
        in_qreg (SSAValue): Input quantum register that will contain the inserted qubit.
        idx (SSAValue): The index in which to insert the qubit. Possibly unknown at compile time.
        idx_attr (IntegerAttr): The index in which to insert the qubits. Known at compile time.
        qubit (SSAValue): The qubit to store at position given by the index.

    Results:
        out_qreg (SSAValue): The updated quantum register.

    .. note::

        The value of in_qreg should never be used again once it has been updated. All
        future uses should refer to out_qreg.
    """

    name = "quantum.insert"

    # assembly_format = """
    #        $in_qreg `[` ($idx^):($idx_attr)? `]` `,` $qubit attr-dict `:` type($in_qreg) `,` type($qubit)
    #    """

    in_qreg = operand_def(QuregType)

    idx = opt_operand_def(IntegerType(64))

    idx_attr = opt_prop_def(AnyAttr())

    qubit = operand_def(QubitType)

    out_qreg = result_def(QuregType)

    def __init__(
        self,
        in_qreg: QuregSSAValue | Operation,
        idx: SSAValue[IntegerType] | Operation | int | IntegerAttr,
        qubit: QubitSSAValue | Operation,
    ):
        if isinstance(idx, int):
            idx = IntegerAttr.from_int_and_width(idx, 64)

        if isinstance(idx, IntegerAttr):
            operands = (in_qreg, None, qubit)
            properties = {"idx_attr": idx}
        else:
            operands = (in_qreg, idx, qubit)
            properties = {}

        super().__init__(operands=operands, properties=properties, result_types=(QuregType(),))


@irdl_op_definition
class MeasureOp(IRDLOperation):
    """A single-qubit projective measurement in the computational basis.

    Args:
        in_qubit (SSAValue): The qubit to measured.
        postselect (int | IntegerAttr | None): Either 0 or 1.

    Results:
        mres (SSAValue): The measurement result given as a boolean value.
        out_qubit (SSAValue): The output qubit in either |0> or |1> state.
    """

    name = "quantum.measure"

    assembly_format = """
        $in_qubit (`postselect` $postselect^)? attr-dict `:` type(results)
    """

    in_qubit = operand_def(QubitType)

    postselect = opt_prop_def(IntegerAttr[I32])

    mres = result_def(IntegerType(1))

    out_qubit = result_def(QubitType)

    def __init__(
        self, in_qubit: QubitSSAValue | Operation, postselect: int | IntegerAttr | None = None
    ):
        if isinstance(postselect, int):
            postselect = IntegerAttr.from_int_and_width(postselect, 32)

        if postselect is None:
            properties = {}
        else:
            properties = {"postselect": postselect}

        super().__init__(
            operands=(in_qubit,), properties=properties, result_types=(IntegerType(1), QubitType())
        )

    def verify_(self):
        """Verify operation when rewriting."""
        if self.postselect is None:
            return

        if self.postselect.value.data not in [0, 1]:  # pylint: disable=no-member
            raise VerifyException("'postselect' must be 0 or 1.")


@irdl_op_definition
class MultiRZOp(IRDLOperation):
    """Apply an arbitrary multi Z rotation.

    The `quantum.multirz` operation applies an arbitrary multi Z rotation to the state-vector.

    Args:
        theta (SSAValue): rotation angle
        in_qubits (Sequence[SSAValue]): the set of qubits the operation acts on
        in_ctrl_qubits (Sequence[SSAValue]): Control qubits.
        in_ctrl_values (Sequence[SSAValue | bool]): Control values. Must be True or False.

    Results:
        out_qubits (Sequence[SSAValue]): The output qubits.
        out_ctrl_qubits (Sequence[SSAVAlue]): The output control qubits.

    .. note::

        This operation is one of the few quantum operations that is not applied via
        quantum.custom. The reason for this is that it needs to be handled in a special
        way during the lowering due to its C function being variadic on the number of qubits.
    """

    name = "quantum.multirz"

    assembly_format = """
        `(` $theta `)` $in_qubits
        (`adj` $adjoint^)?
        attr-dict
        ( `ctrls` `(` $in_ctrl_qubits^ `)` )?
        ( `ctrlvals` `(` $in_ctrl_values^ `)` )?
        `:` type($out_qubits) (`ctrls` type($out_ctrl_qubits)^ )?
    """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    theta = operand_def(Float64Type())

    in_qubits = var_operand_def(QubitType)

    adjoint = opt_prop_def(UnitAttr)

    in_ctrl_qubits = var_operand_def(QubitType)

    in_ctrl_values = var_operand_def(IntegerType(1))

    out_qubits = var_result_def(QubitType)

    out_ctrl_qubits = var_result_def(QubitType)


@irdl_op_definition
class NamedObsOp(IRDLOperation):
    """Define a Named observable for use in measurements.

    The `quantum.namedobs` operation defines a quantum observable to be used by measurement
    processes. The specific observable defined here represents one of 5 named observables
    {Identity, PauliX, PauliY, PauliZ, Hadamard} on a qubit. The arguments are a qubit to
    measure as well as an encoding operator for the qubit as an integer between 0-4.

    **Example**

    .. code-block:: mlir

        func.func @foo(%q: !quantum.bit)
        {
            %res = quantum.namedobs %q[4] : !quantum.obs
            func.return
        }

    """

    name = "quantum.namedobs"

    assembly_format = """
        $qubit `[` $type `]` attr-dict  `:` type(results)
    """

    qubit = operand_def(QubitType)

    type = prop_def(NamedObservableAttr)

    obs = result_def(ObservableType)

    def __init__(self, qubit: QubitSSAValue | Operation, obs_type: NamedObservableAttr):
        super().__init__(
            operands=(qubit,), properties={"type": obs_type}, result_types=(ObservableType(),)
        )


@irdl_op_definition
class ProbsOp(IRDLOperation):
    """Compute computational basis probabilities for the current state"""

    name = "quantum.probs"

    assembly_format = """
        $obs ( `shape` $dynamic_shape^ )?
        ( `in` `(` $state_in^ `:` type($state_in) `)` )?
        attr-dict ( `:` type($probabilities)^ )?
    """

    irdl_options = [AttrSizedOperandSegments(as_property=True)]

    obs = operand_def(ObservableType)

    dynamic_shape = opt_operand_def(IntegerType(64))

    state_in = opt_operand_def(AnyAttr())

    probabilities = opt_result_def(AnyAttr())


@irdl_op_definition
class QubitUnitaryOp(IRDLOperation):
    """Apply an arbitrary fixed unitary matrix"""

    name = "quantum.unitary"

    assembly_format = """
        `(` $matrix `:` type($matrix) `)` $in_qubits
        (`adj` $adjoint^)?
        attr-dict
        ( `ctrls` `(` $in_ctrl_qubits^ `)` )?
        ( `ctrlvals` `(` $in_ctrl_values^ `)` )?
        `:` type($out_qubits) (`ctrls` type($out_ctrl_qubits)^ )?
    """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    matrix = operand_def(AnyAttr())

    in_qubits = var_operand_def(QubitType)

    adjoint = opt_prop_def(UnitAttr)

    in_ctrl_qubits = var_operand_def(QubitType)

    in_ctrl_values = var_operand_def(IntegerType(1))

    out_qubits = var_result_def(QubitType)

    out_ctrl_qubits = var_result_def(QubitType)


@irdl_op_definition
class SampleOp(IRDLOperation):
    """Sample eigenvalues from the given observable for the current state"""

    name = "quantum.sample"

    assembly_format = """
        $obs ( `shape` $dynamic_shape^ )?
        ( `in` `(` $in_data^ `:` type($in_data) `)` )?
        attr-dict ( `:` type($samples)^ )?
    """

    irdl_options = [AttrSizedOperandSegments(as_property=True)]

    obs = operand_def(ObservableType)

    dynamic_shape = var_operand_def(IntegerType(64))

    in_data = opt_operand_def(AnyAttr())

    samples = opt_result_def(AnyAttr())


@irdl_op_definition
class SetBasisStateOp(IRDLOperation):
    """Set basis state."""

    name = "quantum.set_basis_state"

    assembly_format = """
        `(` $basis_state`)` $in_qubits attr-dict `:` functional-type(operands, results)
    """

    basis_state = operand_def(AnyAttr())

    in_qubits = var_operand_def(QubitType)

    out_qubits = var_result_def(QubitType)


@irdl_op_definition
class SetStateOp(IRDLOperation):
    """Set state to a complex vector."""

    name = "quantum.set_state"

    assembly_format = """
        `(` $in_state `)` $in_qubits attr-dict `:` functional-type(operands, results)
    """

    in_state = operand_def(AnyAttr())

    in_qubits = var_operand_def(QubitType)

    out_qubits = var_result_def(QubitType)


@irdl_op_definition
class StateOp(IRDLOperation):
    """Return the current statevector"""

    name = "quantum.state"

    assembly_format = """
        $obs ( `shape` $dynamic_shape^ )?
        ( `in` `(` $state_in^ `:` type($state_in) `)` )?
        attr-dict ( `:` type($state)^ )?
    """

    irdl_options = [AttrSizedOperandSegments(as_property=True)]

    obs = operand_def(ObservableType)

    dynamic_shape = opt_operand_def(IntegerType(64))

    state_in = opt_operand_def(AnyAttr())

    state = opt_result_def(AnyAttr())


@irdl_op_definition
class TensorOp(IRDLOperation):
    """Define a tensor product of observables for use in measurements"""

    name = "quantum.tensor"

    assembly_format = """
        $terms attr-dict `:` type(results)
    """

    terms = var_operand_def(ObservableType)

    obs = result_def(ObservableType)


@irdl_op_definition
class VarianceOp(IRDLOperation):
    """Compute the variance of the given observable for the current state"""

    name = "quantum.var"

    assembly_format = """
        $obs attr-dict `:` type(results)
    """

    obs = operand_def(ObservableType)

    variance = result_def(Float64Type())


@irdl_op_definition
class YieldOp(IRDLOperation):
    """Return results from quantum program regions"""

    name = "quantum.yield"

    assembly_format = """
        attr-dict ($retvals^ `:` type($retvals))?
    """

    retvals = var_operand_def(QuregType)


Quantum = Dialect(
    "quantum",
    [
        AdjointOp,
        AllocOp,
        ComputationalBasisOp,
        CountsOp,
        CustomOp,
        DeallocOp,
        DeviceInitOp,
        DeviceReleaseOp,
        ExpvalOp,
        ExtractOp,
        FinalizeOp,
        GlobalPhaseOp,
        HamiltonianOp,
        HermitianOp,
        InitializeOp,
        InsertOp,
        MeasureOp,
        MultiRZOp,
        NamedObsOp,
        ProbsOp,
        QubitUnitaryOp,
        SampleOp,
        SetBasisStateOp,
        SetStateOp,
        StateOp,
        TensorOp,
        VarianceOp,
        YieldOp,
    ],
    [
        ObservableType,
        QubitType,
        QuregType,
        ResultType,
        NamedObservableAttr,
    ],
)
