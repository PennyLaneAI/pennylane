# Copyright 2025 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
This file contains the definition of the Quantum dialect for the Python compiler.

The Quantum dialect is a set of operations and types used to represent quantum computations
in the xDSL framework.

It was initially generated by xDSL (using the ``xdsl-tblgen`` tool)
starting from the catalyst/mlir/include/Quantum/IR/QuantumOps.td file in the catalyst repository.
"""

# pylint: disable=too-few-public-methods

# pragma: no cover

from typing import Sequence, TypeAlias

from xdsl.dialects.builtin import (
    I32,
    I64,
    AnyAttr,
    Float64Type,
    FloatAttr,
    IntegerAttr,
    IntegerType,
    StringAttr,
    UnitAttr,
    i64,
)
from xdsl.ir import (
    Block,
    Dialect,
    EnumAttribute,
    Operation,
    ParametrizedAttribute,
    Region,
    SpacedOpaqueSyntaxAttribute,
    SSAValue,
    StrEnum,
    TypeAttribute,
)
from xdsl.irdl import (
    AttrSizedOperandSegments,
    AttrSizedResultSegments,
    IRDLOperation,
    irdl_attr_definition,
    irdl_op_definition,
    operand_def,
    opt_operand_def,
    opt_prop_def,
    opt_result_def,
    prop_def,
    region_def,
    result_def,
    var_operand_def,
    var_result_def,
)
from xdsl.utils.exceptions import VerifyException

################################################################
######################## ATTRIBUTES ############################
################################################################


@irdl_attr_definition
class ObservableType(ParametrizedAttribute, TypeAttribute):
    """A quantum observable for use in measurements.

    Operations that may return an observable are:
    * quantum.compbasis
    * quantum.hamiltonian
    * quantum.hermitian
    * quantum.named_observable
    """

    name = "quantum.obs"


@irdl_attr_definition
class QubitType(ParametrizedAttribute, TypeAttribute):
    """A value-semantic qubit (state)."""

    name = "quantum.bit"


@irdl_attr_definition
class QuregType(ParametrizedAttribute, TypeAttribute):
    """An array of value-semantic qubits (i.e. quantum register)."""

    name = "quantum.reg"


@irdl_attr_definition
class ResultType(ParametrizedAttribute, TypeAttribute):
    """A quantum measurement result.

    This is unused but defined in Catalyst. May be scheduled for deletion.
    """

    name = "quantum.res"


class NamedObservable(StrEnum):
    """Known named observables"""

    Identity = "Identity"
    PauliX = "PauliX"
    PauliY = "PauliY"
    PauliZ = "PauliZ"
    Hadamard = "Hadamard"


@irdl_attr_definition
class NamedObservableAttr(EnumAttribute[NamedObservable], SpacedOpaqueSyntaxAttribute):
    """Known named observables"""

    name = "quantum.named_observable"


################################################################
######################## OPERATIONS ############################
################################################################


QubitSSAValue: TypeAlias = SSAValue[QubitType]
QuregSSAValue: TypeAlias = SSAValue[QuregType]
ObservableSSAValue: TypeAlias = SSAValue[ObservableType]


@irdl_op_definition
class AdjointOp(IRDLOperation):
    """Calculate the adjoint of the enclosed operations.

    This operation takes as an input a quantum register and outputs
    an updated quantum register. Its body may contain arbitrary
    quantum operations, including nested adjoint operations.

    Args:
        qreg (QuregSSAValue | Operation): input quantum register. If it is an operation
            then this operation must return a single value
            and that value must be a quantum register.
        region: operations to convert to adjoints. May include control flow and classical operations.

    **Example**

    The PennyLane operations

    .. code-block:: python

        def my_ops():
            qml.Hadamard(0)
            qml.S(0)

        qml.adjoint(my_ops)()

    are equivalent to

    .. code-block:: mlir

        %register_0 = quantum.alloc(1) : !quantum.reg

        %register_3 = quantum.adjoint(%register_0) {
        ^bb0(%register_1: !quantum.reg):
          %qubit_0 = quantum.extract %register_1[ 0] : !quantum.reg -> !quantum.bit
          %qubit_1 = quantum.custom "Hadamard"() %qubit_0 : !quantum.bit
          %qubit_2 = quantum.custom "S"() %qubit_1 : !quantum.bit
          %register_2 = quantum.insert %register_1[ 0], %qubit_2 : !quantum.reg, !quantum.bit
          quantum.yield %register_2
        }

    When the transformation `--adjoint-lowering` is applied, then the ``AdjointOp`` is replaced
    by individual adjoint gates in reverse order.

    .. code-block:: mlir

        %register_0 = quantum.alloc(1) : !quantum.reg
        %qubit_0 = quantum.extract %arg0[0] : !quantum.bit

        // Notice that the order has been reversed.
                      // notice the adj attribute V
        %qubit_1 = quantum.custom "S"() %qubit_0 adj : !quantum.bit
                             // notice the adj attribute V
        %qubit_2 = quantum.custom "Hadamard"() %qubit_1 adj : !quantum.bit

        %register_1 = quantum.insert %original_register[0], %qubit_2 : !quantum.reg, !quantum.bit


    **Example**

    Below is an example with control flow and classical operations:

    .. code-block:: python

        import pennylane as qml
        from catalyst import cond

        @qml.qjit
        @qml.qnode(qml.device("null.qubit", wires=1))
        def foo(x: bool):

        def my_ops(x):

            @cond(x)
            def conditional():
                y = 1.
                qml.RX(y, wires=[0])

            @conditional.otherwise
            def false_path():
                z = 2.
                qml.RX(z, wires=[0])

            conditional()

        qml.adjoint(my_ops)(x)
        return qml.probs()

    This produces the following IR (only showing the relevant pieces):


    .. code-block:: mlir

        %1 = quantum.adjoint(%0) : !quantum.reg {
        ^bb0(%arg1: !quantum.reg):
            %extracted_1 = tensor.extract %arg0[] : tensor<i1>
            %4 = scf.if %extracted_1 -> (!quantum.reg) {
                // ... snip ...
                scf.yield %6 : !quantum.reg
            } else {
                // ... snip ...
                scf.yield %6 : !quantum.reg
            }
            quantum.yield %4 : !quantum.reg
        }
        %2 = quantum.compbasis qreg %1 : !quantum.obs


    When the transformation `--adjoint-lowering` is applied, then the classical parameters are stored in a list
    as it executes the classical components first. Parameters will then be popped from the end of this list
    to obtain them in reverse order.

    .. code-block:: mlir

        // parameters
        %dyn_params = catalyst.list_init : <f64>
        // wires
        %dyn_wires = catalyst.list_init : <i64>
        // conditional variable
        %conditionals = catalyst.list_init : <index>

        // Execution of classical operations in correct order.
        // %x here corresponds to the x variable
        // in Python
        catalyst.list_push %x, %conditionals : <index>

        scf.if %x {
            // %cst here corresponds to y
            catalyst.list_push %cst, %dyn_params : <f64>
        } else {
            // %cst_0 here corresponds to z
            catalyst.list_push %cst_0, %dyn_params : <f64>
        }

        // popping happens in reverse order.
        %5 = catalyst.list_pop %conditionals : <index>
        %6 = index.casts %5 : index to i1

        // quantum execution in reverse order.
        %7 = scf.if %6 -> (!quantum.reg) {
            %10 = quantum.extract %0[ 0] : !quantum.reg -> !quantum.bit
            %11 = catalyst.list_pop %1 : <f64>
            %out_qubits = quantum.custom "RX"(%11) %10 adj : !quantum.bit
            %12 = quantum.insert %0[ 0], %out_qubits : !quantum.reg, !quantum.bit
            scf.yield %12 : !quantum.reg
        } else {
            %10 = quantum.extract %0[ 0] : !quantum.reg -> !quantum.bit
            %11 = catalyst.list_pop %1 : <f64>
            %out_qubits = quantum.custom "RX"(%11) %10 adj : !quantum.bit
            %12 = quantum.insert %0[ 0], %out_qubits : !quantum.reg, !quantum.bit
            scf.yield %12 : !quantum.reg
        }

        // Deallocating memory needed for the parameters and wires.
        catalyst.list_dealloc %dyn_params : <f64>
        catalyst.list_dealloc %dyn_wires : <i64>
        catalyst.list_dealloc %conditionals : <index>

    """

    name = "quantum.adjoint"

    assembly_format = """
        `(` $qreg `)` attr-dict `:` type(operands) $region
    """

    qreg = operand_def(QuregType)

    out_qreg = result_def(QuregType)

    region = region_def("single_block")

    def __init__(
        self,
        qreg: QuregSSAValue | Operation,
        region: Region | Sequence[Operation] | Sequence[Block],
    ):
        super().__init__(operands=(qreg,), result_types=(QuregType(),), regions=(region,))


@irdl_op_definition
class AllocOp(IRDLOperation):
    """Allocate n qubits into a quantum register.

    Args:
        nqubits (int | IntegerAttr | SSAValue): Quantity of wires/qubits in the state vector.
            If the value for `nqubits` is either an Python integer
            or an IntegerAttr, then the number is known at compile time.
            If it is an SSAValue, then it is likely that this value is
            computed at runtime.

    """

    name = "quantum.alloc"

    # TODO: https://github.com/xdslproject/xdsl/pull/4295
    # assembly_format = """
    #        `(` ($nqubits^):($nqubits_attr)? `)` attr-dict `:` type(results)
    #    """

    nqubits = opt_operand_def(i64)

    nqubits_attr = opt_prop_def(IntegerAttr[I64])

    qreg = result_def(QuregType)

    def __init__(self, nqubits: int | IntegerAttr | SSAValue):
        if isinstance(nqubits, int):
            nqubits = IntegerAttr.from_int_and_width(nqubits, 64)

        if isinstance(nqubits, IntegerAttr):
            operands = (None,)
            properties = {"nqubits_attr": nqubits}
        else:
            operands = (nqubits,)
            properties = {}

        super().__init__(operands=operands, properties=properties, result_types=(QuregType(),))

    def verify_(self):
        """Verify operation when rewriting."""
        if self.nqubits_attr is None:
            return

        if self.nqubits_attr.value.data < 0:  # pylint: disable=no-member
            raise VerifyException("Cannot allocate less than zero qubits.")


@irdl_op_definition
class ComputationalBasisOp(IRDLOperation):
    """Define a pseudo-obeservable in the computational basis for use in measurements.

    Args:
        qubits (Sequence[SSAValue] | None): Qubits that make up the computational basis.
        qreg: (SSAValue | None): Quantum register that makes up the computational basis.

    .. note::

        Either qubits or qreg must be supplied.

    """

    name = "quantum.compbasis"

    assembly_format = """
        (`qubits` $qubits^)? (`qreg` $qreg^)? attr-dict `:` type(results)
    """

    irdl_options = [AttrSizedOperandSegments(as_property=True)]

    qubits = var_operand_def(QubitType)

    qreg = opt_operand_def(QuregType)

    obs = result_def(ObservableType)

    # TODO: Add init to validate qubit or qreg was supplied


@irdl_op_definition
class CountsOp(IRDLOperation):
    """Compute sample counts for the given observable for the current state.

    The `quantum.counts` operation represents the measurement process of sampling eigenvalues
    from an observable on the current quantum state and counting the frequency of each
    eigenvalue.

    Args:
        obs (Observable): The only SSA argument is an observable that must be defined by an
            operation in the local scope. The number of samples to draw is determined by the
            device shots argument in the device initialization operation in the local scope.

    Returns:
        eigvals: An array for the eigenvalues. These are the possible bitstrings one could measure
            on the given qubits, encoded as (floating-point) integers.
        counts: An array counting each eigenvalue.

    .. note::

        ``in_eigvals`` and ``in_counts`` will in general not be required when working
        with xDSL. This is due to an implementation detail in Catalyst.
        These inputs correspond to the input memory that will hold the output
        ``eigvals`` and ``counts``.

    **Example**

    .. code-block:: mlir

        func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit, %shots: i64)
        {
            quantum.device shots(%shots) ["rtd_lightning.so", "lightning.qubit", "{my_attr: my_attr_value}"]
            %obs = quantum.compbasis %q0, %q1 : !quantum.obs

            // Notice two tensors with a single dimension being returned.
            %counts = quantum.counts %obs : tensor<4xf64>, tensor<4xi64>

            %obs2 = quantum.pauli %q0[3], %q1[1] : !quantum.obs
            %counts2 = quantum.counts %obs2 : tensor<2xf64>, tensor<2xi64>

            func.return
        }

    """

    name = "quantum.counts"

    assembly_format = """
        $obs ( `shape` $dynamic_shape^ )?
        ( `in` `(` $in_eigvals^ `:` type($in_eigvals) `,` $in_counts `:` type($in_counts) `)` )?
        attr-dict ( `:` type($eigvals)^ `,` type($counts) )?
    """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    obs = operand_def(ObservableType)

    dynamic_shape = opt_operand_def(IntegerType(64))

    in_eigvals = opt_operand_def(AnyAttr())

    in_counts = opt_operand_def(AnyAttr())

    eigvals = opt_result_def(AnyAttr())

    counts = opt_result_def(AnyAttr())


@irdl_op_definition
class CustomOp(IRDLOperation):
    """A generic quantum gate on n qubits with m floating point parameters.

    This operation represents an quantum operation acting on wires.
    This operation may be adjoint, or may be controlled.

    Args:
        name (string | StringAttr): The operation's name. E.g., Hadamard.
        params (Sequence[SSAValue]): The classical parameters.
        in_qubits (Sequence[SSAValue]): The qubits the operation acts on.
        adjoint (UnitAttr | bool | None): Denotes whether the operation is an adjoint.
            If a ``UnitAttr`` or ``True`` value is passed, then the operation is an adjoint.
        in_ctrl_qubits (Sequence[SSAValue]): Control qubits.
        in_ctrl_values (Sequence[SSAValue | bool]): Control values. Must be True or False.

    Returns:
        out_qubits (Sequence[SSAValue]): The output qubits.
        out_ctrl_qubits (Sequence[SSAVAlue]): The output control qubits.

    .. note::

        We say that an operation is "controlled" if it has in_ctrl_qubits. Therefore a CNOT
        operation is not controlled in this context since both its control and target wires are
        contained within ``in_qubits``.

        The same number of ``in_ctrl_qubits`` and ``in_ctrl_values`` are required.

        The semantics of these gates are given by the runtime.

    **Example**

    .. code-block:: mlir

        %out_qubit = quantum.custom "RX"(%param) %in_qubit

    """

    name = "quantum.custom"

    assembly_format = """
        $gate_name `(` $params `)` $in_qubits
        (`adj` $adjoint^)?
        attr-dict
        ( `ctrls` `(` $in_ctrl_qubits^ `)` )?
        ( `ctrlvals` `(` $in_ctrl_values^ `)` )?
        `:` type($out_qubits) (`ctrls` type($out_ctrl_qubits)^ )?
    """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    params = var_operand_def(Float64Type())

    in_qubits = var_operand_def(QubitType)

    gate_name = prop_def(StringAttr)

    adjoint = opt_prop_def(UnitAttr)

    in_ctrl_qubits = var_operand_def(QubitType)

    in_ctrl_values = var_operand_def(IntegerType(1))

    out_qubits = var_result_def(QubitType)

    out_ctrl_qubits = var_result_def(QubitType)

    # pylint: disable=too-many-arguments
    def __init__(
        self,
        *,
        in_qubits: QubitSSAValue | Operation | Sequence[QubitSSAValue | Operation],
        gate_name: str | StringAttr,
        params: SSAValue[Float64Type] | Sequence[SSAValue[Float64Type]] | None = None,
        in_ctrl_qubits: (
            QubitSSAValue | Operation | Sequence[QubitSSAValue | Operation] | None
        ) = None,
        in_ctrl_values: (
            SSAValue[IntegerType]
            | Operation
            | Sequence[SSAValue[IntegerType]]
            | Sequence[Operation]
            | None
        ) = None,
        adjoint: UnitAttr | bool = False,
    ):
        params = () if params is None else params
        in_ctrl_qubits = () if in_ctrl_qubits is None else in_ctrl_qubits
        in_ctrl_values = () if in_ctrl_values is None else in_ctrl_values

        if not isinstance(params, Sequence):
            params = (params,)
        if not isinstance(in_qubits, Sequence):
            in_qubits = (in_qubits,)
        if not isinstance(in_ctrl_qubits, Sequence):
            in_ctrl_qubits = (in_ctrl_qubits,)
        if not isinstance(in_ctrl_values, Sequence):
            in_ctrl_values = (in_ctrl_values,)

        if isinstance(gate_name, str):
            gate_name = StringAttr(data=gate_name)

        out_qubits = tuple(QubitType() for _ in in_qubits)
        out_ctrl_qubits = tuple(QubitType() for _ in in_ctrl_qubits)
        properties = {"gate_name": gate_name}
        if adjoint:
            properties["adjoint"] = UnitAttr()

        super().__init__(
            operands=(params, in_qubits, in_ctrl_qubits, in_ctrl_values),
            result_types=(out_qubits, out_ctrl_qubits),
            properties=properties,
        )


@irdl_op_definition
class DeallocOp(IRDLOperation):
    """Deallocate a quantum register.

    Args:
        qreg (QregSSAValue): The quantum register to deallocate
    """

    name = "quantum.dealloc"

    assembly_format = """
        $qreg attr-dict `:` type(operands)
    """

    qreg = operand_def(QuregType)

    def __init__(self, qreg: QuregSSAValue | Operation):
        super().__init__(operands=(qreg,))


@irdl_op_definition
class DeviceInitOp(IRDLOperation):
    """Initialize a quantum device.

    Args:
        shots (SSAValue | None): number of shots requested by the user.
        lib (StringAttr): The location of the shared object that contains the implementation of
            the QuantumDevice interface.
        device_name (StringAttr): Name of the device.
        kwargs (StringAttr): Static input to the device that can be helpful for passing options.
    """

    name = "quantum.device"

    assembly_format = """
        (`shots` `(` $shots^ `)`)? `[` $lib `,` $device_name `,` $kwargs `]` attr-dict
    """

    shots = opt_operand_def(IntegerType(64))

    lib = prop_def(StringAttr)

    device_name = prop_def(StringAttr)

    kwargs = prop_def(StringAttr)


@irdl_op_definition
class DeviceReleaseOp(IRDLOperation):
    """Release the active quantum device.

    Once this operation executes, the quantum device is released back into the pool of available devices.
    For software simulators, valid semantics include resetting the simulator.
    """

    name = "quantum.device_release"

    assembly_format = "attr-dict"


@irdl_op_definition
class ExpvalOp(IRDLOperation):
    """Compute the expectation value of the given observable for the current state.

    The ``quantum.expval`` operation represents the measurement process of computing the
    expectation value of an observable on the current quantum state. While this quantity can
    be computed analytically on simulators, for hardware execution or shot noise
    simulation, the shots attached to the device in the local scope are used.

    Args:
        obs (SSAValue): an observable that must be defined by an operation in the local scope.

    Results:
        expval (f64): The expectation value.


    .. code-block:: mlir

        func.func @foo(%q: !quantum.bit)
        {
            %obs = quantum.namedobs %q[4] : !quantum.obs
            %expval = quantum.expval %obs : f64
            func.return
        }
    """

    name = "quantum.expval"

    assembly_format = "$obs attr-dict `:` type(results)"

    obs = operand_def(ObservableType)

    expval = result_def(Float64Type())

    def __init__(self, obs: ObservableSSAValue | Operation):
        super().__init__(operands=(obs,), result_types=(Float64Type(),))


@irdl_op_definition
class ExtractOp(IRDLOperation):
    """Extract a qubit value from a register.

    Args:
        qreg (QregSSAValue): The quantum register containing the qubit to be extracted.
        idx (SSAValue | None): An index that may correspond to an unknown wire.
        idx_attr (IntegerAttr | int): An index that is statically known.

    Results:
        qubit: The extracted qubit.
    """

    name = "quantum.extract"

    # assembly_format = """
    #        $qreg `[` ($idx^):($idx_attr)? `]` attr-dict `:` type($qreg) `->` type(results)
    #    """

    qreg = operand_def(QuregType)

    idx = opt_operand_def(IntegerType(64))

    idx_attr = opt_prop_def(AnyAttr())

    qubit = result_def(QubitType)

    def __init__(
        self,
        qreg: QuregSSAValue | Operation,
        idx: int | SSAValue[IntegerType] | Operation | IntegerAttr,
    ):
        if isinstance(idx, int):
            idx = IntegerAttr.from_int_and_width(idx, 64)

        if isinstance(idx, IntegerAttr):
            operands = (qreg, None)
            properties = {"idx_attr": idx}
        else:
            operands = (qreg, idx)
            properties = {}

        super().__init__(
            operands=operands,
            result_types=(QubitType(),),
            properties=properties,
        )


@irdl_op_definition
class FinalizeOp(IRDLOperation):
    """Teardown the quantum runtime.

    Executing this instruction concretely corresponds to executing the
    ``__catalyst__rt__finalize`` function in the runtime which is expected
    to be the very last thing executed by the library.
    """

    name = "quantum.finalize"

    assembly_format = "attr-dict"


@irdl_op_definition
class GlobalPhaseOp(IRDLOperation):
    """Global Phase.

    Applies global phase to the current system.

    Args:
        params (SSAValue | float): The global phase
        in_ctrl_qubits (SSAValue): The control qubits.
        in_ctrl_values (SSAValue): The control values.

    Results:
        out_ctrl_qubits: The control qubits

    .. note::

        With the introduction of dynamic qubit allocation, applying a global
        phase and then creating a new qubit results in undefined behaviour.
    """

    name = "quantum.gphase"

    assembly_format = """
           `(` $params `)` 
           attr-dict 
           ( `ctrls` `(` $in_ctrl_qubits^ `)` )?  
           ( `ctrlvals` `(` $in_ctrl_values^ `)` )? 
           `:` type(results)
       """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    params = operand_def(Float64Type())

    in_ctrl_qubits = var_operand_def(QubitType)

    in_ctrl_values = var_operand_def(IntegerType(1))

    out_ctrl_qubits = var_result_def(QubitType)

    # pylint: disable=too-many-arguments
    def __init__(
        self,
        *,
        params: float | SSAValue[Float64Type],
        in_ctrl_qubits: (
            QubitSSAValue | Operation | Sequence[QubitSSAValue | Operation] | None
        ) = None,
        in_ctrl_values: (
            SSAValue[IntegerType]
            | Operation
            | Sequence[SSAValue[IntegerType]]
            | Sequence[Operation]
            | None
        ) = None,
    ):
        if isinstance(params, float):
            params = FloatAttr(data=params, type=Float64Type())
        in_ctrl_qubits = () if in_ctrl_qubits is None else in_ctrl_qubits
        in_ctrl_values = () if in_ctrl_values is None else in_ctrl_values

        if not isinstance(in_ctrl_qubits, Sequence):
            in_ctrl_qubits = (in_ctrl_qubits,)
        if not isinstance(in_ctrl_values, Sequence):
            in_ctrl_values = (in_ctrl_values,)

        out_ctrl_qubits = tuple(QubitType() for _ in in_ctrl_qubits)

        super().__init__(
            operands=(params, in_ctrl_qubits, in_ctrl_values),
            result_types=(out_ctrl_qubits,),
        )


@irdl_op_definition
class HamiltonianOp(IRDLOperation):
    """Define a Hamiltonian observable for use in measurements.

    The ``quantum.hamiltonian`` operation defines a quantum observable to be used by other
    operations such as measurement processes. The specific observable defined here represents
    a linear combination of observables. The arguments are a set of coefficients and a set of
    ``quantum.Observable`` generated by ``quantum.namedobs``, ``quantum.hermitian``,
    or ``quantum.tensorobs``.

    **Example**

    .. code-block:: mlir

        func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit, %c: tensor<2xf64>) {
            %obs1 = quantum.namedobs %q0[4] : !quantum.obs
            %obs2 = quantum.namedobs %q1[2] : !quantum.obs
            %res = quantum.hamiltonian(%c: tensor<2xf64>) %obs1, %obs2 : !quantum.obs
            func.return
        }
    """

    name = "quantum.hamiltonian"

    assembly_format = """
        `(` $coeffs `:` type($coeffs) `)` $terms attr-dict `:` type(results)
    """

    coeffs = operand_def(AnyAttr())

    terms = var_operand_def(ObservableType)

    obs = result_def(ObservableType)


@irdl_op_definition
class HermitianOp(IRDLOperation):
    """Define a Hermitian observable for use in measurements.

    The ``quantum.hermitian`` operation defines a quantum observable to be used by measurement
    processes. The specific observable defined here represents the Hermitian observable on a
    set of qubits. The arguments are a set of qubits to measure as well as a row-major flattened
    matrix of complex numbers that represents a Hermitian matrix that must be of size
    :math:`2^{num_qubits} \times 2^{n_qubits}`.
    """

    name = "quantum.hermitian"

    assembly_format = """
        `(` $matrix `:` type($matrix) `)` $qubits attr-dict `:` type(results)
    """

    matrix = operand_def(AnyAttr())

    qubits = var_operand_def(QubitType)

    obs = result_def(ObservableType)


@irdl_op_definition
class InitializeOp(IRDLOperation):
    """Initialize the quantum runtime.

    The execution of this operation corresponds to the execution of Catalyst's runtime function
    ``__catalyst__rt__initialize`` which is the first function that will be called for the duration
    of the whole compiled object.
    """

    name = "quantum.init"

    assembly_format = "attr-dict"


@irdl_op_definition
class InsertOp(IRDLOperation):
    """Update the qubit value of a register.

    Args:
        in_qreg (SSAValue): Input quantum register that will contain the inserted qubit.
        idx (SSAValue | Operation | int | IntegerAttr): The index in which to insert the qubit. Possibly
            unknown at compile time.
        qubit (SSAValue): The qubit to store at position given by the index.

    Results:
        out_qreg (SSAValue): The updated quantum register.

    .. note::

        The value of ``in_qreg`` should never be used again once it has been updated. All
        future uses should refer to ``out_qreg``.
    """

    name = "quantum.insert"

    # assembly_format = """
    #        $in_qreg `[` ($idx^):($idx_attr)? `]` `,` $qubit attr-dict `:` type($in_qreg) `,` type($qubit)
    #    """

    in_qreg = operand_def(QuregType)

    idx = opt_operand_def(IntegerType(64))

    idx_attr = opt_prop_def(AnyAttr())

    qubit = operand_def(QubitType)

    out_qreg = result_def(QuregType)

    def __init__(
        self,
        in_qreg: QuregSSAValue | Operation,
        idx: SSAValue[IntegerType] | Operation | int | IntegerAttr,
        qubit: QubitSSAValue | Operation,
    ):
        if isinstance(idx, int):
            idx = IntegerAttr.from_int_and_width(idx, 64)

        if isinstance(idx, IntegerAttr):
            operands = (in_qreg, None, qubit)
            properties = {"idx_attr": idx}
        else:
            operands = (in_qreg, idx, qubit)
            properties = {}

        super().__init__(operands=operands, properties=properties, result_types=(QuregType(),))


@irdl_op_definition
class MeasureOp(IRDLOperation):
    """A single-qubit projective measurement in the computational basis.

    Args:
        in_qubit (SSAValue): The qubit to measure.
        postselect (int | IntegerAttr | None): Which computational basis state to postselect (either 0 or 1).
            ``None`` by default.

    Results:
        mres (SSAValue): The measurement result given as a boolean value.
        out_qubit (SSAValue): The output qubit in either the :math:`|0\rangle` or :math:`|1\rangle` state.
    """

    name = "quantum.measure"

    assembly_format = """
        $in_qubit (`postselect` $postselect^)? attr-dict `:` type(results)
    """

    in_qubit = operand_def(QubitType)

    postselect = opt_prop_def(IntegerAttr[I32])

    mres = result_def(IntegerType(1))

    out_qubit = result_def(QubitType)

    def __init__(
        self, in_qubit: QubitSSAValue | Operation, postselect: int | IntegerAttr | None = None
    ):
        if isinstance(postselect, int):
            postselect = IntegerAttr.from_int_and_width(postselect, 32)

        if postselect is None:
            properties = {}
        else:
            properties = {"postselect": postselect}

        super().__init__(
            operands=(in_qubit,), properties=properties, result_types=(IntegerType(1), QubitType())
        )

    def verify_(self):
        """Verify operation when rewriting."""
        if self.postselect is None:
            return

        if self.postselect.value.data not in [0, 1]:  # pylint: disable=no-member
            raise VerifyException("'postselect' must be 0 or 1.")


@irdl_op_definition
class MultiRZOp(IRDLOperation):
    """Apply an arbitrary multi Z rotation.

    The ``quantum.multirz`` operation applies an arbitrary multi Z rotation to the state-vector.

    Args:
        theta (SSAValue): rotation angle
        in_qubits (Sequence[SSAValue]): the set of qubits the operation acts on
        adjoint (UnitAttr | bool | None): Denotes whether the operation is an adjoint.
            If a ``UnitAttr`` or ``True`` value is passed, then the operation is an adjoint.
        in_ctrl_qubits (Sequence[SSAValue]): Control qubits.
        in_ctrl_values (Sequence[SSAValue | bool]): Control values. Must be ``True`` or ``False``.

    Results:
        out_qubits (Sequence[SSAValue]): The output qubits.
        out_ctrl_qubits (Sequence[SSAVAlue]): The output control qubits.

    .. note::

        This operation is one of the few quantum operations that is not applied via
        ``quantum.custom``. The reason for this is that it needs to be handled in a special
        way during the lowering due to its C function being variadic on the number of qubits.
    """

    name = "quantum.multirz"

    assembly_format = """
        `(` $theta `)` $in_qubits
        (`adj` $adjoint^)?
        attr-dict
        ( `ctrls` `(` $in_ctrl_qubits^ `)` )?
        ( `ctrlvals` `(` $in_ctrl_values^ `)` )?
        `:` type($out_qubits) (`ctrls` type($out_ctrl_qubits)^ )?
    """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    theta = operand_def(Float64Type())

    in_qubits = var_operand_def(QubitType)

    adjoint = opt_prop_def(UnitAttr)

    in_ctrl_qubits = var_operand_def(QubitType)

    in_ctrl_values = var_operand_def(IntegerType(1))

    out_qubits = var_result_def(QubitType)

    out_ctrl_qubits = var_result_def(QubitType)


@irdl_op_definition
class NamedObsOp(IRDLOperation):
    """Define a Named observable for use in measurements.

    The ``quantum.namedobs`` operation defines a quantum observable to be used by measurement
    processes. The specific observable defined here represents one of 5 named observables --
    Identity, PauliX, PauliY, PauliZ, Hadamard -- on a qubit. The arguments are the qubit to
    measure as well as an encoding operator for the qubit as an integer between 0-4 inclusive.

    **Example**

    .. code-block:: mlir

        func.func @foo(%q: !quantum.bit)
        {
            %res = quantum.namedobs %q[4] : !quantum.obs
            func.return
        }

    """

    name = "quantum.namedobs"

    assembly_format = """
        $qubit `[` $type `]` attr-dict  `:` type(results)
    """

    qubit = operand_def(QubitType)

    type = prop_def(NamedObservableAttr)

    obs = result_def(ObservableType)

    def __init__(self, qubit: QubitSSAValue | Operation, obs_type: NamedObservableAttr):
        super().__init__(
            operands=(qubit,), properties={"type": obs_type}, result_types=(ObservableType(),)
        )


@irdl_op_definition
class ProbsOp(IRDLOperation):
    """Compute computational basis probabilities for the current state.

    The ``quantum.probs`` operation represents the measurement process of computing probabilities
    for measurement outcomes in the computational basis for a set of qubits.
    Marginal probabilities are supported, that is, the provided qubits do not need to make up the
    entire state vector.

    The result array contains one element for each possible bitstring, i.e. ``2^n`` where ``n`` is the
    number of qubits.

    **Example**

    .. code-block:: mlir

        func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit)
        {
            %probs = quantum.probs %q0, %q1 : tensor<4xf64>
            func.return
        }

    """

    name = "quantum.probs"

    assembly_format = """
        $obs ( `shape` $dynamic_shape^ )?
        ( `in` `(` $state_in^ `:` type($state_in) `)` )?
        attr-dict ( `:` type($probabilities)^ )?
    """

    irdl_options = [AttrSizedOperandSegments(as_property=True)]

    obs = operand_def(ObservableType)

    dynamic_shape = opt_operand_def(IntegerType(64))

    state_in = opt_operand_def(AnyAttr())

    probabilities = opt_result_def(AnyAttr())


@irdl_op_definition
class QubitUnitaryOp(IRDLOperation):
    """Apply an arbitrary fixed unitary matrix.

    Args:
        matrix (SSAValue): matrix to be applied
        in_qubits (Sequence[SSAValue]): The qubits the operation acts on.
        adjoint (UnitAttr | bool | None): Denotes whether the operation is an adjoint.
            If a ``UnitAttr`` or ``True`` value is passed, then the operation is an adjoint.
        in_ctrl_qubits (Sequence[SSAValue]): Control qubits.
        in_ctrl_values (Sequence[SSAValue | bool]): Control values. Must be ``True`` or ``False``.

    Returns:
        out_qubits (Sequence[SSAValue]): The output qubits.
        out_ctrl_qubits (Sequence[SSAVAlue]): The output control qubits.
    """

    name = "quantum.unitary"

    assembly_format = """
        `(` $matrix `:` type($matrix) `)` $in_qubits
        (`adj` $adjoint^)?
        attr-dict
        ( `ctrls` `(` $in_ctrl_qubits^ `)` )?
        ( `ctrlvals` `(` $in_ctrl_values^ `)` )?
        `:` type($out_qubits) (`ctrls` type($out_ctrl_qubits)^ )?
    """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    matrix = operand_def(AnyAttr())

    in_qubits = var_operand_def(QubitType)

    adjoint = opt_prop_def(UnitAttr)

    in_ctrl_qubits = var_operand_def(QubitType)

    in_ctrl_values = var_operand_def(IntegerType(1))

    out_qubits = var_result_def(QubitType)

    out_ctrl_qubits = var_result_def(QubitType)


@irdl_op_definition
class SampleOp(IRDLOperation):
    """Sample eigenvalues from the given observable for the current state.

    The ``quantum.sample`` operation represents the measurement process of sampling eigenvalues
    from an observable on the current quantum state.

    Args:
        obs (SSAValue): an observable that must be defined by an operation in the local scope.

    Results:
        samples (SSAValue): The number of samples to draw is determined by the device shots argument in the device initialization operation in the local scope.


    .. note::

        The return value type depends on the type of observable provided. Computational
        basis samples are returned as a 2D array of shape (shot number, number of qubits), with all
        other obversables the output is a 1D array of lenth equal to the shot number.

    .. note::

        The ``in_data`` field is needed only after bufferization. It is an implementation detail that
        transform writers are unlikely to be worried about.

    **Example**

    .. code-block:: mlir

        func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit, %shots: i64)
        {
            quantum.device shots(%shots) ["rtd_lightning.so", "lightning.qubit", "{my_attr: my_attr_value}"]
            %obs1 = quantum.compbasis %q0, %q1 : !quantum.obs
            %samples = quantum.samples %obs1 : tensor<?xf64>

            %obs2 = quantum.pauli %q0[3], %q1[1] : !quantum.obs
            %samples2 = quantum.samples %obs2 : tensor<?x2xf64>

            func.return
        }
    """

    name = "quantum.sample"

    assembly_format = """
        $obs ( `shape` $dynamic_shape^ )?
        ( `in` `(` $in_data^ `:` type($in_data) `)` )?
        attr-dict ( `:` type($samples)^ )?
    """

    irdl_options = [AttrSizedOperandSegments(as_property=True)]

    obs = operand_def(ObservableType)

    dynamic_shape = var_operand_def(IntegerType(64))

    in_data = opt_operand_def(AnyAttr())

    samples = opt_result_def(AnyAttr())


@irdl_op_definition
class SetBasisStateOp(IRDLOperation):
    """Set basis state.

    Args:
        basis_state (SSAValue): basis state
        in_qubits (Sequence[SSAValue]): The qubits the operation acts on.

    Returns:
        out_qubits (Sequence[SSAValue]): The output qubits.

    .. note::

        This operation should be the first quantum operation of the entry point of
        a quantum module.
    """

    name = "quantum.set_basis_state"

    assembly_format = """
        `(` $basis_state`)` $in_qubits attr-dict `:` functional-type(operands, results)
    """

    basis_state = operand_def(AnyAttr())

    in_qubits = var_operand_def(QubitType)

    out_qubits = var_result_def(QubitType)


@irdl_op_definition
class SetStateOp(IRDLOperation):
    """Set state to a complex vector.

    Args:
        basis_state (SSAValue): basis state
        in_qubits (Sequence[SSAValue]): The qubits the operation acts on.

    Returns:
        out_qubits (Sequence[SSAValue]): The output qubits.

    .. note::

        This operation should be the first quantum operation of the entry point of
        a quantum module.
    """

    name = "quantum.set_state"

    assembly_format = """
        `(` $in_state `)` $in_qubits attr-dict `:` functional-type(operands, results)
    """

    in_state = operand_def(AnyAttr())

    in_qubits = var_operand_def(QubitType)

    out_qubits = var_result_def(QubitType)


@irdl_op_definition
class StateOp(IRDLOperation):
    """Return the current statevector.

    The ``quantum.state`` operation represents the measurement process of returning the current
    statevector in the computational basis. Typically reserved for simulator devices, although
    in principle also achievable on hardware via tomography techniques.
    While marginal states are supported, the operation is only well-defined if the provided
    qubits are not entangled with the rest of the quantum state.
    The result array contains one (complex) element for each possible bitstring, i.e. ``2^n`` where
    ``n`` is the number of qubits.

    **Example**

    .. code-block:: mlir

        func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit)
        {
            %state = quantum.state %q0, %q1 : tensor<4xcomplex<f64>>
            func.return
        }
    """

    name = "quantum.state"

    assembly_format = """
        $obs ( `shape` $dynamic_shape^ )?
        ( `in` `(` $state_in^ `:` type($state_in) `)` )?
        attr-dict ( `:` type($state)^ )?
    """

    irdl_options = [AttrSizedOperandSegments(as_property=True)]

    obs = operand_def(ObservableType)

    dynamic_shape = opt_operand_def(IntegerType(64))

    state_in = opt_operand_def(AnyAttr())

    state = opt_result_def(AnyAttr())


@irdl_op_definition
class TensorOp(IRDLOperation):
    """Define a tensor product of observables for use in measurements.

    The ``quantum.tensor`` operation defines a quantum observable to be used by other
    operations such as measurement processes. The specific observable defined here represents
    the tensor product of observables on a set of qubits. The arguments are a set of
    ``quantum.obs`` generated by ``quantum.namedobs`` and ``quantum.hermitian``.

    Args:
        obs (Sequence[SSAValue[ObservableType] | Operation]): observables that must be defined by
            operations in the local scope.

    **Example**

    .. code-block:: mlir

        func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit, %m: tensor<2x2xcomplex<f64>>)
        {
            %obs1 = quantum.namedobs %q0[4] : !quantum.obs
            %obs2 = quantum.hermitian(%m: tensor<2x2xcomplex<f64>>) %q1 : !quantum.obs
            %res = quantum.tensorprod %obs1, %obs2 : !quantum.obs
            func.return
        }

    """

    name = "quantum.tensor"

    assembly_format = """
        $terms attr-dict `:` type(results)
    """

    terms = var_operand_def(ObservableType)

    obs = result_def(ObservableType)


@irdl_op_definition
class VarianceOp(IRDLOperation):
    """Compute the variance of the given observable for the current state

    The ``quantum.var`` operation represents the measurement process of computing the variance of
    an observable on the current quantum state. While this quantity can be computed analytically on simulators, for hardware execution or shot noise
    simulation, the shots attached to the device in the local scope are used.

    Args:
        obs (SSAValue[ObservableType] | Operation): an observable that must be defined by
            an operation in the local scope.

    **Example**

    .. code-block:: mlir

        func.func @foo(%q: !quantum.bit)
        {
            %obs = quantum.namedobs %q[4] : !quantum.obs
            %var = quantum.var %obs : f64

            func.return
        }
    """

    name = "quantum.var"

    assembly_format = """
        $obs attr-dict `:` type(results)
    """

    obs = operand_def(ObservableType)

    variance = result_def(Float64Type())


@irdl_op_definition
class YieldOp(IRDLOperation):
    """Return results from quantum program regions.

    .. note::

        This operation must be a child of ``quantum.adjoint``
    """

    name = "quantum.yield"

    assembly_format = """
        attr-dict ($retvals^ `:` type($retvals))?
    """

    retvals = var_operand_def(QuregType)


Quantum = Dialect(
    "quantum",
    [
        AdjointOp,
        AllocOp,
        ComputationalBasisOp,
        CountsOp,
        CustomOp,
        DeallocOp,
        DeviceInitOp,
        DeviceReleaseOp,
        ExpvalOp,
        ExtractOp,
        FinalizeOp,
        GlobalPhaseOp,
        HamiltonianOp,
        HermitianOp,
        InitializeOp,
        InsertOp,
        MeasureOp,
        MultiRZOp,
        NamedObsOp,
        ProbsOp,
        QubitUnitaryOp,
        SampleOp,
        SetBasisStateOp,
        SetStateOp,
        StateOp,
        TensorOp,
        VarianceOp,
        YieldOp,
    ],
    [
        ObservableType,
        QubitType,
        QuregType,
        ResultType,
        NamedObservableAttr,
    ],
)
