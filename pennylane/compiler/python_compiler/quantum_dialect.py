# Copyright 2025 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
This file contains the definition of the Quantum dialect for the Python compiler.

The Quantum dialect is a set of operations and types used to represent quantum computations
in the xDSL framework.

It was initially generated by xDSL (using the ``xdsl-tblgen`` tool)
starting from the catalyst/mlir/include/Quantum/IR/QuantumOps.td file in the catalyst repository.
"""

# pylint: disable=too-few-public-methods

# pragma: no cover

from collections.abc import Sequence
from typing import TypeAlias

from xdsl.dialects.builtin import (
    I32,
    I64,
    AnyAttr,
    Float64Type,
    FloatAttr,
    IntegerAttr,
    IntegerType,
    StringAttr,
    UnitAttr,
    i64,
)
from xdsl.ir import (
    Block,
    Dialect,
    EnumAttribute,
    Operation,
    ParametrizedAttribute,
    Region,
    SpacedOpaqueSyntaxAttribute,
    SSAValue,
    StrEnum,
    TypeAttribute,
)
from xdsl.irdl import (
    AttrSizedOperandSegments,
    AttrSizedResultSegments,
    IRDLOperation,
    irdl_attr_definition,
    irdl_op_definition,
    operand_def,
    opt_operand_def,
    opt_prop_def,
    opt_result_def,
    prop_def,
    region_def,
    result_def,
    var_operand_def,
    var_result_def,
)
from xdsl.utils.exceptions import VerifyException

################################################################
######################## ATTRIBUTES ############################
################################################################


@irdl_attr_definition
class ObservableType(ParametrizedAttribute, TypeAttribute):
    """A quantum observable for use in measurements."""

    name = "quantum.obs"


@irdl_attr_definition
class QubitType(ParametrizedAttribute, TypeAttribute):
    """A value-semantic qubit (state)."""

    name = "quantum.bit"


@irdl_attr_definition
class QuregType(ParametrizedAttribute, TypeAttribute):
    """An array of value-semantic qubits (i.e. quantum register)."""

    name = "quantum.reg"


@irdl_attr_definition
class ResultType(ParametrizedAttribute, TypeAttribute):
    """A quantum measurement result."""

    name = "quantum.res"


class NamedObservable(StrEnum):
    """Known named observables"""

    Identity = "Identity"
    PauliX = "PauliX"
    PauliY = "PauliY"
    PauliZ = "PauliZ"
    Hadamard = "Hadamard"


@irdl_attr_definition
class NamedObservableAttr(EnumAttribute[NamedObservable], SpacedOpaqueSyntaxAttribute):
    """Known named observables"""

    name = "quantum.named_observable"


################################################################
######################## OPERATIONS ############################
################################################################


QubitSSAValue: TypeAlias = SSAValue[QubitType]
QuregSSAValue: TypeAlias = SSAValue[QuregType]
ObservableSSAValue: TypeAlias = SSAValue[ObservableType]


@irdl_op_definition
class AdjointOp(IRDLOperation):
    """Calculate the adjoint of the enclosed operations"""

    name = "quantum.adjoint"

    assembly_format = """
        `(` $qreg `)` attr-dict `:` type(operands) $region
    """

    qreg = operand_def(QuregType)

    out_qreg = result_def(QuregType)

    region = region_def("single_block")

    def __init__(
        self,
        qreg: QuregSSAValue | Operation,
        region: Region | Sequence[Operation] | Sequence[Block],
    ):
        super().__init__(operands=(qreg,), result_types=(QuregType(),), regions=(region,))


@irdl_op_definition
class AllocOp(IRDLOperation):
    """Allocate n qubits into a quantum register."""

    name = "quantum.alloc"

    # assembly_format = """
    #        `(` ($nqubits^):($nqubits_attr)? `)` attr-dict `:` type(results)
    #    """

    nqubits = opt_operand_def(i64)

    nqubits_attr = opt_prop_def(IntegerAttr[I64])

    qreg = result_def(QuregType)

    def __init__(self, nqubits):
        if isinstance(nqubits, int):
            nqubits = IntegerAttr.from_int_and_width(nqubits, 64)

        if isinstance(nqubits, IntegerAttr):
            operands = (None,)
            properties = {"nqubits_attr": nqubits}
        else:
            operands = (nqubits,)
            properties = {}

        super().__init__(operands=operands, properties=properties, result_types=(QuregType(),))

    def verify_(self):
        """Verify operation when rewriting."""
        if self.nqubits_attr is None:
            return

        if self.nqubits_attr.value.data < 0:  # pylint: disable=no-member
            raise VerifyException("Cannot allocate less than zero qubits.")


@irdl_op_definition
class ComputationalBasisOp(IRDLOperation):
    """Define a pseudo-obeservable of the computational basis for use in measurements"""

    name = "quantum.compbasis"

    assembly_format = """
        (`qubits` $qubits^)? (`qreg` $qreg^)? attr-dict `:` type(results)
    """

    irdl_options = [AttrSizedOperandSegments(as_property=True)]

    qubits = var_operand_def(QubitType)

    qreg = opt_operand_def(QuregType)

    obs = result_def(ObservableType)


@irdl_op_definition
class CountsOp(IRDLOperation):
    """Compute sample counts for the given observable for the current state"""

    name = "quantum.counts"

    assembly_format = """
        $obs ( `shape` $dynamic_shape^ )?
        ( `in` `(` $in_eigvals^ `:` type($in_eigvals) `,` $in_counts `:` type($in_counts) `)` )?
        attr-dict ( `:` type($eigvals)^ `,` type($counts) )?
    """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    obs = operand_def(ObservableType)

    dynamic_shape = opt_operand_def(IntegerType(64))

    in_eigvals = opt_operand_def(AnyAttr())

    in_counts = opt_operand_def(AnyAttr())

    eigvals = opt_result_def(AnyAttr())

    counts = opt_result_def(AnyAttr())


@irdl_op_definition
class CustomOp(IRDLOperation):
    """A generic quantum gate on n qubits with m floating point parameters."""

    name = "quantum.custom"

    assembly_format = """
        $gate_name `(` $params `)` $in_qubits
        (`adj` $adjoint^)?
        attr-dict
        ( `ctrls` `(` $in_ctrl_qubits^ `)` )?
        ( `ctrlvals` `(` $in_ctrl_values^ `)` )?
        `:` type($out_qubits) (`ctrls` type($out_ctrl_qubits)^ )?
    """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    params = var_operand_def(Float64Type())

    in_qubits = var_operand_def(QubitType)

    gate_name = prop_def(StringAttr)

    adjoint = opt_prop_def(UnitAttr)

    in_ctrl_qubits = var_operand_def(QubitType)

    in_ctrl_values = var_operand_def(IntegerType(1))

    out_qubits = var_result_def(QubitType)

    out_ctrl_qubits = var_result_def(QubitType)

    # pylint: disable=too-many-arguments
    def __init__(
        self,
        *,
        in_qubits: QubitSSAValue | Operation | Sequence[QubitSSAValue | Operation],
        gate_name: str | StringAttr,
        params: SSAValue[Float64Type] | Sequence[SSAValue[Float64Type]] | None = None,
        in_ctrl_qubits: (
            QubitSSAValue | Operation | Sequence[QubitSSAValue | Operation] | None
        ) = None,
        in_ctrl_values: (
            SSAValue[IntegerType]
            | Operation
            | Sequence[SSAValue[IntegerType]]
            | Sequence[Operation]
            | None
        ) = None,
        adjoint: UnitAttr | bool = False,
    ):
        params = () if params is None else params
        in_ctrl_qubits = () if in_ctrl_qubits is None else in_ctrl_qubits
        in_ctrl_values = () if in_ctrl_values is None else in_ctrl_values

        if not isinstance(params, Sequence):
            params = (params,)
        if not isinstance(in_qubits, Sequence):
            in_qubits = (in_qubits,)
        if not isinstance(in_ctrl_qubits, Sequence):
            in_ctrl_qubits = (in_ctrl_qubits,)
        if not isinstance(in_ctrl_values, Sequence):
            in_ctrl_values = (in_ctrl_values,)

        if isinstance(gate_name, str):
            gate_name = StringAttr(data=gate_name)

        out_qubits = tuple(QubitType() for _ in in_qubits)
        out_ctrl_qubits = tuple(QubitType() for _ in in_ctrl_qubits)
        properties = {"gate_name": gate_name}
        if adjoint:
            properties["adjoint"] = UnitAttr()

        super().__init__(
            operands=(params, in_qubits, in_ctrl_qubits, in_ctrl_values),
            result_types=(out_qubits, out_ctrl_qubits),
            properties=properties,
        )


@irdl_op_definition
class DeallocOp(IRDLOperation):
    """Deallocate a quantum register."""

    name = "quantum.dealloc"

    assembly_format = """
        $qreg attr-dict `:` type(operands)
    """

    qreg = operand_def(QuregType)

    def __init__(self, qreg: QuregSSAValue | Operation):
        super().__init__(operands=(qreg,))


@irdl_op_definition
class DeviceInitOp(IRDLOperation):
    """Initialize a quantum device."""

    name = "quantum.device"

    assembly_format = """
        (`shots` `(` $shots^ `)`)? `[` $lib `,` $device_name `,` $kwargs `]` attr-dict
    """

    shots = opt_operand_def(IntegerType(64))

    lib = prop_def(StringAttr)

    device_name = prop_def(StringAttr)

    kwargs = prop_def(StringAttr)


@irdl_op_definition
class DeviceReleaseOp(IRDLOperation):
    """Release the active quantum device."""

    name = "quantum.device_release"

    assembly_format = "attr-dict"


@irdl_op_definition
class ExpvalOp(IRDLOperation):
    """Compute the expectation value of the given observable for the current state"""

    name = "quantum.expval"

    assembly_format = "$obs attr-dict `:` type(results)"

    obs = operand_def(ObservableType)

    expval = result_def(Float64Type())

    def __init__(self, obs: ObservableSSAValue | Operation):
        super().__init__(operands=(obs,), result_types=(Float64Type(),))


@irdl_op_definition
class ExtractOp(IRDLOperation):
    """Extract a qubit value from a register."""

    name = "quantum.extract"

    # assembly_format = """
    #        $qreg `[` ($idx^):($idx_attr)? `]` attr-dict `:` type($qreg) `->` type(results)
    #    """

    qreg = operand_def(QuregType)

    idx = opt_operand_def(IntegerType(64))

    idx_attr = opt_prop_def(AnyAttr())

    qubit = result_def(QubitType)

    def __init__(
        self,
        qreg: QuregSSAValue | Operation,
        idx: int | SSAValue[IntegerType] | Operation | IntegerAttr,
    ):
        if isinstance(idx, int):
            idx = IntegerAttr.from_int_and_width(idx, 64)

        if isinstance(idx, IntegerAttr):
            operands = (qreg, None)
            properties = {"idx_attr": idx}
        else:
            operands = (qreg, idx)
            properties = {}

        super().__init__(
            operands=operands,
            result_types=(QubitType(),),
            properties=properties,
        )


@irdl_op_definition
class FinalizeOp(IRDLOperation):
    """Teardown the quantum runtime."""

    name = "quantum.finalize"

    assembly_format = "attr-dict"


@irdl_op_definition
class GlobalPhaseOp(IRDLOperation):
    """Global Phase."""

    name = "quantum.gphase"

    assembly_format = """
           `(` $params `)` 
           attr-dict 
           ( `ctrls` `(` $in_ctrl_qubits^ `)` )?  
           ( `ctrlvals` `(` $in_ctrl_values^ `)` )? 
           `:` type(results)
       """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    params = operand_def(Float64Type())

    in_ctrl_qubits = var_operand_def(QubitType)

    in_ctrl_values = var_operand_def(IntegerType(1))

    out_ctrl_qubits = var_result_def(QubitType)

    # pylint: disable=too-many-arguments
    def __init__(
        self,
        *,
        params: float | SSAValue[Float64Type],
        in_ctrl_qubits: (
            QubitSSAValue | Operation | Sequence[QubitSSAValue | Operation] | None
        ) = None,
        in_ctrl_values: (
            SSAValue[IntegerType]
            | Operation
            | Sequence[SSAValue[IntegerType]]
            | Sequence[Operation]
            | None
        ) = None,
    ):
        if isinstance(params, float):
            params = FloatAttr(data=params, type=Float64Type())
        in_ctrl_qubits = () if in_ctrl_qubits is None else in_ctrl_qubits
        in_ctrl_values = () if in_ctrl_values is None else in_ctrl_values

        if not isinstance(in_ctrl_qubits, Sequence):
            in_ctrl_qubits = (in_ctrl_qubits,)
        if not isinstance(in_ctrl_values, Sequence):
            in_ctrl_values = (in_ctrl_values,)

        out_ctrl_qubits = tuple(QubitType() for _ in in_ctrl_qubits)

        super().__init__(
            operands=(params, in_ctrl_qubits, in_ctrl_values),
            result_types=(out_ctrl_qubits,),
        )


@irdl_op_definition
class HamiltonianOp(IRDLOperation):
    """Define a Hamiltonian observable for use in measurements"""

    name = "quantum.hamiltonian"

    assembly_format = """
        `(` $coeffs `:` type($coeffs) `)` $terms attr-dict `:` type(results)
    """

    coeffs = operand_def(AnyAttr())

    terms = var_operand_def(ObservableType)

    obs = result_def(ObservableType)


@irdl_op_definition
class HermitianOp(IRDLOperation):
    """Define a Hermitian observable for use in measurements"""

    name = "quantum.hermitian"

    assembly_format = """
        `(` $matrix `:` type($matrix) `)` $qubits attr-dict `:` type(results)
    """

    matrix = operand_def(AnyAttr())

    qubits = var_operand_def(QubitType)

    obs = result_def(ObservableType)


@irdl_op_definition
class InitializeOp(IRDLOperation):
    """Initialize the quantum runtime."""

    name = "quantum.init"

    assembly_format = "attr-dict"


@irdl_op_definition
class InsertOp(IRDLOperation):
    """Update the qubit value of a register."""

    name = "quantum.insert"

    # assembly_format = """
    #        $in_qreg `[` ($idx^):($idx_attr)? `]` `,` $qubit attr-dict `:` type($in_qreg) `,` type($qubit)
    #    """

    in_qreg = operand_def(QuregType)

    idx = opt_operand_def(IntegerType(64))

    idx_attr = opt_prop_def(AnyAttr())

    qubit = operand_def(QubitType)

    out_qreg = result_def(QuregType)

    def __init__(
        self,
        in_qreg: QuregSSAValue | Operation,
        idx: SSAValue[IntegerType] | Operation | int | IntegerAttr,
        qubit: QubitSSAValue | Operation,
    ):
        if isinstance(idx, int):
            idx = IntegerAttr.from_int_and_width(idx, 64)

        if isinstance(idx, IntegerAttr):
            operands = (in_qreg, None, qubit)
            properties = {"idx_attr": idx}
        else:
            operands = (in_qreg, idx, qubit)
            properties = {}

        super().__init__(operands=operands, properties=properties, result_types=(QuregType(),))


@irdl_op_definition
class MeasureOp(IRDLOperation):
    """A single-qubit projective measurement in the computational basis."""

    name = "quantum.measure"

    assembly_format = """
        $in_qubit (`postselect` $postselect^)? attr-dict `:` type(results)
    """

    in_qubit = operand_def(QubitType)

    postselect = opt_prop_def(IntegerAttr[I32])

    mres = result_def(IntegerType(1))

    out_qubit = result_def(QubitType)

    def __init__(
        self, in_qubit: QubitSSAValue | Operation, postselect: int | IntegerAttr | None = None
    ):
        if isinstance(postselect, int):
            postselect = IntegerAttr.from_int_and_width(postselect, 32)

        if postselect is None:
            properties = {}
        else:
            properties = {"postselect": postselect}

        super().__init__(
            operands=(in_qubit,), properties=properties, result_types=(IntegerType(1), QubitType())
        )

    def verify_(self):
        """Verify operation when rewriting."""
        if self.postselect is None:
            return

        if self.postselect.value.data not in [0, 1]:  # pylint: disable=no-member
            raise VerifyException("'postselect' must be 0 or 1.")


@irdl_op_definition
class MultiRZOp(IRDLOperation):
    """Apply an arbitrary multi Z rotation"""

    name = "quantum.multirz"

    assembly_format = """
        `(` $theta `)` $in_qubits
        (`adj` $adjoint^)?
        attr-dict
        ( `ctrls` `(` $in_ctrl_qubits^ `)` )?
        ( `ctrlvals` `(` $in_ctrl_values^ `)` )?
        `:` type($out_qubits) (`ctrls` type($out_ctrl_qubits)^ )?
    """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    theta = operand_def(Float64Type())

    in_qubits = var_operand_def(QubitType)

    adjoint = opt_prop_def(UnitAttr)

    in_ctrl_qubits = var_operand_def(QubitType)

    in_ctrl_values = var_operand_def(IntegerType(1))

    out_qubits = var_result_def(QubitType)

    out_ctrl_qubits = var_result_def(QubitType)


@irdl_op_definition
class NamedObsOp(IRDLOperation):
    """Define a Named observable for use in measurements"""

    name = "quantum.namedobs"

    assembly_format = """
        $qubit `[` $type `]` attr-dict  `:` type(results)
    """

    qubit = operand_def(QubitType)

    type = prop_def(NamedObservableAttr)

    obs = result_def(ObservableType)

    def __init__(self, qubit: QubitSSAValue | Operation, obs_type: NamedObservableAttr):
        super().__init__(
            operands=(qubit,), properties={"type": obs_type}, result_types=(ObservableType(),)
        )


@irdl_op_definition
class ProbsOp(IRDLOperation):
    """Compute computational basis probabilities for the current state"""

    name = "quantum.probs"

    assembly_format = """
        $obs ( `shape` $dynamic_shape^ )?
        ( `in` `(` $state_in^ `:` type($state_in) `)` )?
        attr-dict ( `:` type($probabilities)^ )?
    """

    irdl_options = [AttrSizedOperandSegments(as_property=True)]

    obs = operand_def(ObservableType)

    dynamic_shape = opt_operand_def(IntegerType(64))

    state_in = opt_operand_def(AnyAttr())

    probabilities = opt_result_def(AnyAttr())


@irdl_op_definition
class QubitUnitaryOp(IRDLOperation):
    """Apply an arbitrary fixed unitary matrix"""

    name = "quantum.unitary"

    assembly_format = """
        `(` $matrix `:` type($matrix) `)` $in_qubits
        (`adj` $adjoint^)?
        attr-dict
        ( `ctrls` `(` $in_ctrl_qubits^ `)` )?
        ( `ctrlvals` `(` $in_ctrl_values^ `)` )?
        `:` type($out_qubits) (`ctrls` type($out_ctrl_qubits)^ )?
    """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    matrix = operand_def(AnyAttr())

    in_qubits = var_operand_def(QubitType)

    adjoint = opt_prop_def(UnitAttr)

    in_ctrl_qubits = var_operand_def(QubitType)

    in_ctrl_values = var_operand_def(IntegerType(1))

    out_qubits = var_result_def(QubitType)

    out_ctrl_qubits = var_result_def(QubitType)


@irdl_op_definition
class SampleOp(IRDLOperation):
    """Sample eigenvalues from the given observable for the current state"""

    name = "quantum.sample"

    assembly_format = """
        $obs ( `shape` $dynamic_shape^ )?
        ( `in` `(` $in_data^ `:` type($in_data) `)` )?
        attr-dict ( `:` type($samples)^ )?
    """

    irdl_options = [AttrSizedOperandSegments(as_property=True)]

    obs = operand_def(ObservableType)

    dynamic_shape = var_operand_def(IntegerType(64))

    in_data = opt_operand_def(AnyAttr())

    samples = opt_result_def(AnyAttr())


@irdl_op_definition
class SetBasisStateOp(IRDLOperation):
    """Set basis state."""

    name = "quantum.set_basis_state"

    assembly_format = """
        `(` $basis_state`)` $in_qubits attr-dict `:` functional-type(operands, results)
    """

    basis_state = operand_def(AnyAttr())

    in_qubits = var_operand_def(QubitType)

    out_qubits = var_result_def(QubitType)


@irdl_op_definition
class SetStateOp(IRDLOperation):
    """Set state to a complex vector."""

    name = "quantum.set_state"

    assembly_format = """
        `(` $in_state `)` $in_qubits attr-dict `:` functional-type(operands, results)
    """

    in_state = operand_def(AnyAttr())

    in_qubits = var_operand_def(QubitType)

    out_qubits = var_result_def(QubitType)


@irdl_op_definition
class StateOp(IRDLOperation):
    """Return the current statevector"""

    name = "quantum.state"

    assembly_format = """
        $obs ( `shape` $dynamic_shape^ )?
        ( `in` `(` $state_in^ `:` type($state_in) `)` )?
        attr-dict ( `:` type($state)^ )?
    """

    irdl_options = [AttrSizedOperandSegments(as_property=True)]

    obs = operand_def(ObservableType)

    dynamic_shape = opt_operand_def(IntegerType(64))

    state_in = opt_operand_def(AnyAttr())

    state = opt_result_def(AnyAttr())


@irdl_op_definition
class TensorOp(IRDLOperation):
    """Define a tensor product of observables for use in measurements"""

    name = "quantum.tensor"

    assembly_format = """
        $terms attr-dict `:` type(results)
    """

    terms = var_operand_def(ObservableType)

    obs = result_def(ObservableType)


@irdl_op_definition
class VarianceOp(IRDLOperation):
    """Compute the variance of the given observable for the current state"""

    name = "quantum.var"

    assembly_format = """
        $obs attr-dict `:` type(results)
    """

    obs = operand_def(ObservableType)

    variance = result_def(Float64Type())


@irdl_op_definition
class YieldOp(IRDLOperation):
    """Return results from quantum program regions"""

    name = "quantum.yield"

    assembly_format = """
        attr-dict ($retvals^ `:` type($retvals))?
    """

    retvals = var_operand_def(QuregType)


QuantumDialect = Dialect(
    "quantum",
    [
        AdjointOp,
        AllocOp,
        ComputationalBasisOp,
        CountsOp,
        CustomOp,
        DeallocOp,
        DeviceInitOp,
        DeviceReleaseOp,
        ExpvalOp,
        ExtractOp,
        FinalizeOp,
        GlobalPhaseOp,
        HamiltonianOp,
        HermitianOp,
        InitializeOp,
        InsertOp,
        MeasureOp,
        MultiRZOp,
        NamedObsOp,
        ProbsOp,
        QubitUnitaryOp,
        SampleOp,
        SetBasisStateOp,
        SetStateOp,
        StateOp,
        TensorOp,
        VarianceOp,
        YieldOp,
    ],
    [
        ObservableType,
        QubitType,
        QuregType,
        ResultType,
        NamedObservableAttr,
    ],
)
