# Copyright 2025 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
This file contains the definition of the Quantum dialect for the Python compiler.

The Quantum dialect is a set of operations and types used to represent quantum computations
in the xDSL framework.

It was initially generated by xDSL (using the ``xdsl-tblgen`` tool)
starting from the catalyst/mlir/include/Quantum/IR/QuantumOps.td file in the catalyst repository.
"""

# pylint: disable=too-few-public-methods

# pragma: no cover

from xdsl.dialects.builtin import (
    AnyAttr,
    AnyOf,
    BaseAttr,
    Float64Type,
    IntegerType,
    StringAttr,
    UnitAttr,
)
from xdsl.ir import (
    Dialect,
    EnumAttribute,
    ParametrizedAttribute,
    SpacedOpaqueSyntaxAttribute,
    StrEnum,
    TypeAttribute,
)
from xdsl.irdl import (
    AttrSizedOperandSegments,
    AttrSizedResultSegments,
    EqAttrConstraint,
    IRDLOperation,
    irdl_attr_definition,
    irdl_op_definition,
    operand_def,
    opt_operand_def,
    opt_prop_def,
    opt_result_def,
    prop_def,
    region_def,
    result_def,
    var_operand_def,
    var_result_def,
)


@irdl_attr_definition
class ObservableType(ParametrizedAttribute, TypeAttribute):
    """A quantum observable for use in measurements."""

    name = "quantum.obs"


@irdl_attr_definition
class QubitType(ParametrizedAttribute, TypeAttribute):
    """A value-semantic qubit (state)."""

    name = "quantum.bit"


@irdl_attr_definition
class QuregType(ParametrizedAttribute, TypeAttribute):
    """An array of value-semantic qubits (i.e. quantum register)."""

    name = "quantum.reg"


@irdl_attr_definition
class ResultType(ParametrizedAttribute, TypeAttribute):
    """A quantum measurement result."""

    name = "quantum.res"


class NamedObservable(StrEnum):
    """Known named observables"""

    Identity = "Identity"
    PauliX = "PauliX"
    PauliY = "PauliY"
    PauliZ = "PauliZ"
    Hadamard = "Hadamard"


@irdl_attr_definition
class NamedObservableAttr(EnumAttribute[NamedObservable], SpacedOpaqueSyntaxAttribute):
    """Known named observables"""

    name = "quantum.named_observable"


@irdl_op_definition
class AdjointOp(IRDLOperation):
    """Calculate the adjoint of the enclosed operations"""

    name = "quantum.adjoint"

    assembly_format = """
            `(` $qreg `)` attr-dict `:` type(operands) $region
        """

    qreg = operand_def(BaseAttr(QuregType))

    out_qreg = result_def(BaseAttr(QuregType))

    region = region_def("single_block")


@irdl_op_definition
class AllocOp(IRDLOperation):
    """Allocate n qubits into a quantum register."""

    name = "quantum.alloc"

    # assembly_format = """
    #        `(` ($nqubits^):($nqubits_attr)? `)` attr-dict `:` type(results)
    #    """

    nqubits = opt_operand_def(EqAttrConstraint(IntegerType(64)))

    nqubits_attr = opt_prop_def(AnyAttr())

    qreg = result_def(BaseAttr(QuregType))


@irdl_op_definition
class ComputationalBasisOp(IRDLOperation):
    """Define a pseudo-obeservable of the computational basis for use in measurements"""

    name = "quantum.compbasis"

    assembly_format = """
            (`qubits` $qubits^)? (`qreg` $qreg^)? attr-dict `:` type(results)
        """

    irdl_options = [AttrSizedOperandSegments(as_property=True)]

    qubits = var_operand_def(BaseAttr(QubitType))

    qreg = opt_operand_def(BaseAttr(QuregType))

    obs = result_def(BaseAttr(ObservableType))


@irdl_op_definition
class CountsOp(IRDLOperation):
    """Compute sample counts for the given observable for the current state"""

    name = "quantum.counts"

    assembly_format = """
            $obs ( `shape` $dynamic_shape^ )?
            ( `in` `(` $in_eigvals^ `:` type($in_eigvals) `,` $in_counts `:` type($in_counts) `)` )?
            attr-dict ( `:` type($eigvals)^ `,` type($counts) )?
        """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    obs = operand_def(BaseAttr(ObservableType))

    dynamic_shape = opt_operand_def(EqAttrConstraint(IntegerType(64)))

    in_eigvals = opt_operand_def(AnyAttr())

    in_counts = opt_operand_def(AnyAttr())

    eigvals = opt_result_def(AnyAttr())

    counts = opt_result_def(AnyAttr())


@irdl_op_definition
class CustomOp(IRDLOperation):
    """A generic quantum gate on n qubits with m floating point parameters."""

    name = "quantum.custom"

    # assembly_format = """
    #        $gate_name `(` $params `)` $in_qubits attr-dict ( `ctrls` `(` $in_ctrl_qubits^ `)` )?  ( `ctrlvals` `(` $in_ctrl_values^ `)` )? `:` type($out_qubits) (`ctrls` type($out_ctrl_qubits)^ )?
    #    """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    params = var_operand_def(EqAttrConstraint(Float64Type()))

    in_qubits = var_operand_def(BaseAttr(QubitType))

    gate_name = prop_def(BaseAttr(StringAttr))

    adjoint = opt_prop_def(EqAttrConstraint(UnitAttr()))

    in_ctrl_qubits = var_operand_def(BaseAttr(QubitType))

    in_ctrl_values = var_operand_def(EqAttrConstraint(IntegerType(1)))

    out_qubits = var_result_def(BaseAttr(QubitType))

    out_ctrl_qubits = var_result_def(BaseAttr(QubitType))


@irdl_op_definition
class DeallocOp(IRDLOperation):
    """Deallocate a quantum register."""

    name = "quantum.dealloc"

    assembly_format = """
            $qreg attr-dict `:` type(operands)
        """

    qreg = operand_def(BaseAttr(QuregType))


@irdl_op_definition
class DeviceInitOp(IRDLOperation):
    """Initialize a quantum device."""

    name = "quantum.device_init"

    # assembly_format = """
    #      (`shots` `(` $shots^ `)`)? `[` $lib `,` $name `,` $kwargs `]` attr-dict
    #    """

    shots = opt_operand_def(EqAttrConstraint(IntegerType(64)))

    lib = prop_def(BaseAttr(StringAttr))

    kwargs = prop_def(BaseAttr(StringAttr))


@irdl_op_definition
class DeviceReleaseOp(IRDLOperation):
    """Release the active quantum device."""

    name = "quantum.device_release"

    assembly_format = """
            attr-dict
        """


@irdl_op_definition
class ExpvalOp(IRDLOperation):
    """Compute the expectation value of the given observable for the current state"""

    name = "quantum.expval"

    assembly_format = """
            $obs attr-dict `:` type(results)
        """

    obs = operand_def(BaseAttr(ObservableType))

    expval = result_def(EqAttrConstraint(Float64Type()))


@irdl_op_definition
class ExtractOp(IRDLOperation):
    """Extract a qubit value from a register."""

    name = "quantum.extract"

    # assembly_format = """
    #        $qreg `[` ($idx^):($idx_attr)? `]` attr-dict `:` type($qreg) `->` type(results)
    #    """

    qreg = operand_def(BaseAttr(QuregType))

    idx = opt_operand_def(EqAttrConstraint(IntegerType(64)))

    idx_attr = opt_prop_def(AnyAttr())

    qubit = result_def(BaseAttr(QubitType))


@irdl_op_definition
class FinalizeOp(IRDLOperation):
    """Teardown the quantum runtime."""

    name = "quantum.finalize"

    assembly_format = """
            attr-dict
        """


@irdl_op_definition
class GlobalPhaseOp(IRDLOperation):
    """Global Phase."""

    name = "quantum.gphase"

    # assembly_format = """
    #        `(` $params `)` attr-dict ( `ctrls` `(` $in_ctrl_qubits^ `)` )?  ( `ctrlvals` `(` $in_ctrl_values^ `)` )? `:` (`ctrls` type($out_ctrl_qubits)^ )?
    #    """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    params = operand_def(EqAttrConstraint(Float64Type()))

    adjoint = opt_prop_def(EqAttrConstraint(UnitAttr()))

    in_ctrl_qubits = var_operand_def(BaseAttr(QubitType))

    in_ctrl_values = var_operand_def(EqAttrConstraint(IntegerType(1)))

    out_ctrl_qubits = var_result_def(BaseAttr(QubitType))


@irdl_op_definition
class HamiltonianOp(IRDLOperation):
    """Define a Hamiltonian observable for use in measurements"""

    name = "quantum.hamiltonian"

    assembly_format = """
            `(` $coeffs `:` type($coeffs) `)` $terms attr-dict `:` type(results)
        """

    coeffs = operand_def(AnyOf((AnyAttr(), AnyAttr())))

    terms = var_operand_def(BaseAttr(ObservableType))

    obs = result_def(BaseAttr(ObservableType))


@irdl_op_definition
class HermitianOp(IRDLOperation):
    """Define a Hermitian observable for use in measurements"""

    name = "quantum.hermitian"

    assembly_format = """
            `(` $matrix `:` type($matrix) `)` $qubits attr-dict `:` type(results)
        """

    matrix = operand_def(AnyOf((AnyAttr(), AnyAttr())))

    qubits = var_operand_def(BaseAttr(QubitType))

    obs = result_def(BaseAttr(ObservableType))


@irdl_op_definition
class InitializeOp(IRDLOperation):
    """Initialize the quantum runtime."""

    name = "quantum.init"

    assembly_format = """
            attr-dict
        """


@irdl_op_definition
class InsertOp(IRDLOperation):
    """Update the qubit value of a register."""

    name = "quantum.insert"

    # assembly_format = """
    #        $in_qreg `[` ($idx^):($idx_attr)? `]` `,` $qubit attr-dict `:` type($in_qreg) `,` type($qubit)
    #    """

    in_qreg = operand_def(BaseAttr(QuregType))

    idx = opt_operand_def(EqAttrConstraint(IntegerType(64)))

    idx_attr = opt_prop_def(AnyAttr())

    qubit = operand_def(BaseAttr(QubitType))

    out_qreg = result_def(BaseAttr(QuregType))


@irdl_op_definition
class MeasureOp(IRDLOperation):
    """A single-qubit projective measurement in the computational basis."""

    name = "quantum.measure"

    # assembly_format = """
    #        $in_qubit attr-dict `:` type(results)
    #    """

    in_qubit = operand_def(BaseAttr(QubitType))

    postselect = opt_prop_def(AnyAttr())

    mres = result_def(EqAttrConstraint(IntegerType(1)))

    out_qubit = result_def(BaseAttr(QubitType))


@irdl_op_definition
class MultiRZOp(IRDLOperation):
    """Apply an arbitrary multi Z rotation"""

    name = "quantum.multirz"

    # assembly_format = """
    #        `(` $theta `)` $in_qubits attr-dict ( `ctrls` `(` $in_ctrl_qubits^ `)` )?  ( `ctrlvals` `(` $in_ctrl_values^ `)` )? `:` type($out_qubits) (`ctrls` type($out_ctrl_qubits)^ )?
    #    """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    theta = operand_def(EqAttrConstraint(Float64Type()))

    in_qubits = var_operand_def(BaseAttr(QubitType))

    adjoint = opt_prop_def(EqAttrConstraint(UnitAttr()))

    in_ctrl_qubits = var_operand_def(BaseAttr(QubitType))

    in_ctrl_values = var_operand_def(EqAttrConstraint(IntegerType(1)))

    out_qubits = var_result_def(BaseAttr(QubitType))

    out_ctrl_qubits = var_result_def(BaseAttr(QubitType))


@irdl_op_definition
class NamedObsOp(IRDLOperation):
    """Define a Named observable for use in measurements"""

    name = "quantum.namedobs"

    assembly_format = """
            $qubit `[` $type `]` attr-dict  `:` type(results)
        """

    qubit = operand_def(BaseAttr(QubitType))

    type = prop_def(BaseAttr(NamedObservableAttr))

    obs = result_def(BaseAttr(ObservableType))


@irdl_op_definition
class ProbsOp(IRDLOperation):
    """Compute computational basis probabilities for the current state"""

    name = "quantum.probs"

    assembly_format = """
            $obs ( `shape` $dynamic_shape^ )?
            ( `in` `(` $state_in^ `:` type($state_in) `)` )?
            attr-dict ( `:` type($probabilities)^ )?
        """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    obs = operand_def(BaseAttr(ObservableType))

    dynamic_shape = opt_operand_def(EqAttrConstraint(IntegerType(64)))

    state_in = opt_operand_def(AnyAttr())

    probabilities = opt_result_def(AnyAttr())


@irdl_op_definition
class QubitUnitaryOp(IRDLOperation):
    """Apply an arbitrary fixed unitary matrix"""

    name = "quantum.unitary"

    # assembly_format = """
    #        `(` $matrix `:` type($matrix) `)` $in_qubits attr-dict ( `ctrls` `(` $in_ctrl_qubits^ `)` )?  ( `ctrlvals` `(` $in_ctrl_values^ `)` )? `:` type($out_qubits) (`ctrls` type($out_ctrl_qubits)^ )?
    #    """

    irdl_options = [
        AttrSizedOperandSegments(as_property=True),
        AttrSizedResultSegments(as_property=True),
    ]

    matrix = operand_def(AnyOf((AnyAttr(), AnyAttr())))

    in_qubits = var_operand_def(BaseAttr(QubitType))

    adjoint = opt_prop_def(EqAttrConstraint(UnitAttr()))

    in_ctrl_qubits = var_operand_def(BaseAttr(QubitType))

    in_ctrl_values = var_operand_def(EqAttrConstraint(IntegerType(1)))

    out_qubits = var_result_def(BaseAttr(QubitType))

    out_ctrl_qubits = var_result_def(BaseAttr(QubitType))


@irdl_op_definition
class SampleOp(IRDLOperation):
    """Sample eigenvalues from the given observable for the current state"""

    name = "quantum.sample"

    assembly_format = """
            $obs ( `shape` $dynamic_shape^ )?
            ( `in` `(` $in_data^ `:` type($in_data) `)` )?
            attr-dict ( `:` type($samples)^ )?
        """

    irdl_options = [AttrSizedOperandSegments(as_property=True)]

    obs = operand_def(BaseAttr(ObservableType))

    dynamic_shape = var_operand_def(EqAttrConstraint(IntegerType(64)))

    in_data = opt_operand_def(AnyOf((AnyAttr(), AnyAttr())))

    samples = opt_result_def(AnyOf((AnyAttr(), AnyAttr())))


@irdl_op_definition
class SetBasisStateOp(IRDLOperation):
    """Set basis state."""

    name = "quantum.set_basis_state"

    assembly_format = """
            `(` $basis_state`)` $in_qubits attr-dict `:` functional-type(operands, results)
        """

    basis_state = operand_def(AnyOf((AnyAttr(), AnyAttr())))

    in_qubits = var_operand_def(BaseAttr(QubitType))

    out_qubits = var_result_def(BaseAttr(QubitType))


@irdl_op_definition
class SetStateOp(IRDLOperation):
    """Set state to a complex vector."""

    name = "quantum.set_state"

    assembly_format = """
            `(` $in_state `)` $in_qubits attr-dict `:` functional-type(operands, results)
        """

    in_state = operand_def(AnyOf((AnyAttr(), AnyAttr())))

    in_qubits = var_operand_def(BaseAttr(QubitType))

    out_qubits = var_result_def(BaseAttr(QubitType))


@irdl_op_definition
class StateOp(IRDLOperation):
    """Return the current statevector"""

    name = "quantum.state"

    assembly_format = """
            $obs ( `shape` $dynamic_shape^ )?
            ( `in` `(` $state_in^ `:` type($state_in) `)` )?
            attr-dict ( `:` type($state)^ )?
        """

    irdl_options = [AttrSizedOperandSegments(as_property=True)]

    obs = operand_def(BaseAttr(ObservableType))

    dynamic_shape = opt_operand_def(EqAttrConstraint(IntegerType(64)))

    state_in = opt_operand_def(AnyAttr())

    state = opt_result_def(AnyAttr())


@irdl_op_definition
class TensorOp(IRDLOperation):
    """Define a tensor product of observables for use in measurements"""

    name = "quantum.tensor"

    assembly_format = """
            $terms attr-dict `:` type(results)
        """

    terms = var_operand_def(BaseAttr(ObservableType))

    obs = result_def(BaseAttr(ObservableType))


@irdl_op_definition
class VarianceOp(IRDLOperation):
    """Compute the variance of the given observable for the current state"""

    name = "quantum.var"

    assembly_format = """
            $obs attr-dict `:` type(results)
        """

    obs = operand_def(BaseAttr(ObservableType))

    variance = result_def(EqAttrConstraint(Float64Type()))


@irdl_op_definition
class YieldOp(IRDLOperation):
    """Return results from quantum program regions"""

    name = "quantum.yield"

    # assembly_format = """
    #        attr-dict ($results^ `:` type($results))?
    #    """

    results = var_operand_def(BaseAttr(QuregType))


QuantumDialect = Dialect(
    "quantum",
    [
        AdjointOp,
        AllocOp,
        ComputationalBasisOp,
        CountsOp,
        CustomOp,
        DeallocOp,
        DeviceInitOp,
        DeviceReleaseOp,
        ExpvalOp,
        ExtractOp,
        FinalizeOp,
        GlobalPhaseOp,
        HamiltonianOp,
        HermitianOp,
        InitializeOp,
        InsertOp,
        MeasureOp,
        MultiRZOp,
        NamedObsOp,
        ProbsOp,
        QubitUnitaryOp,
        SampleOp,
        SetBasisStateOp,
        SetStateOp,
        StateOp,
        TensorOp,
        VarianceOp,
        YieldOp,
    ],
    [
        ObservableType,
        QubitType,
        QuregType,
        ResultType,
        NamedObservableAttr,
    ],
)
