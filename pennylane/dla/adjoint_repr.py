# Copyright 2024 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""A function to compute the adjoint representation of a Lie algebra"""
# pylint: disable=too-many-arguments
from itertools import combinations

import numpy as np

from pennylane.pauli import PauliSentence


def _all_commutators(ops):
    commutators = {}
    for (j, op1), (k, op2) in combinations(enumerate(ops), r=2):
        res = op1.commutator(op2)
        if res != PauliSentence({}):
            commutators[(j, k)] = res

    return commutators


def adjoint_repr(dla):
    r"""
    Compute the adjoint representation of a dynamical Lie algebra (DLA)

    Given a DLA :math:`\{G_1, G_2, .. G_\mathfrak{d} \}` of dimension :math:`\mathfrak{d}`,
    the adjoint representation :math:`\left(\text{ad}(iG_\gamma)\right)_{\alpha, \beta} = f^\gamma__{\alpha, \beta}` is given by the structure constants

    .. math:: f^\gamma__{\alpha, \beta} = \text{tr}\left(iG_\gamma \cdot \left[G_\alpha, G_\beta \right] \right)

    Args:
        dla (List[PauliSentence]): The (dynamical) Lie algebra for which we want to compute its adjoint representation. DLAs can be generated by a set of
            generators via :func:`~lie_closure`.

    Returns:
        matrix: The adjoint representation of shape ``(d, d, d)``.

    **Example**

    Let us generate the DLA of the transverse field Ising model using :func:`~lie_closure`.

    >>> n = 2
    >>> gens = [
    ...     PauliSentence({PauliWord({i:"X", i+1:"X"}): 1.}) for i in range(n-1)
    ... ]
    >>> gens += [
    ...     PauliSentence({PauliWord({i:"Z"}): 1.}) for i in range(n)
    ... ]
    >>> dla = qml.dla.lie_closure(gens)
    >>> print(dla)
    [1.0 * X(0) @ X(1), 1.0 * Z(0), 1.0 * Z(1), -1.0 * Y(0) @ X(1), -1.0 * X(0) @ Y(1), -1.0 * Y(0) @ Y(1)]

    The dimension of the DLA is :math:`\mathfrak{d} = 6`. Hence, the adjoint representation has shape ``(6, 6, 6)``.

    >>> adjoint_rep = qml.dla.adjoint_repr(dla)
    >>> adjoint_rep.shape
    (6, 6, 6)

    The structure constants tell us the commutation relation between operators in the DLA via

    .. math:: [i G_\alpha, i G_\beta] = \sum_{\gamma = 0}^{\mathfrak{d}-1} f^\gamma_{\alpha, \beta} iG_\gamma.

    Let us confirm those with some examples. Take :math:`[iG_1, iG_3] = [iZ_0, -iY_0 X_1] = i X_0 X_1 = i G_0`, so
    we should have :math:`f^0_{1, 3} = 1.`, which is indeed the case.

    >>> adjoint_rep[0, 1, 3]
    1.

    We can also look at the overall adjoint action of the first element of the DLA, ``1.0 * X(0) @ X(1)``.
    >>> adjoint_rep[0]
    array([[ 0.,  0.,  0.,  0.,  0.,  0.],
           [-0.,  0.,  0.,  1.,  0.,  0.],
           [-0.,  0.,  0.,  0.,  1.,  0.],
           [-0., -1., -0.,  0.,  0.,  0.],
           [-0., -0., -1.,  0.,  0.,  0.],
           [ 0., -0., -0., -0., -0.,  0.]])

    """
    if any((op.pauli_rep is None) for op in dla):
        raise ValueError(
            f"Cannot compute adjoint representation of non-pauli operators. Received {dla}."
        )
    dla = [op.pauli_rep for op in dla]

    commutators = _all_commutators(dla)

    rep = np.zeros((len(dla), len(dla), len(dla)), dtype=float)
    for i, op in enumerate(dla):
        for (j, k), res in commutators.items():
            value = (-1j * (op @ res).trace()).real
            rep[i, j, k] = value
            rep[i, k, j] = -value

    return rep
