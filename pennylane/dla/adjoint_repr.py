# Copyright 2024 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""A function to compute the adjoint representation of a Lie algebra"""
from itertools import combinations

import numpy as np

import pennylane as qml
from pennylane.pauli import PauliSentence


def _all_commutators(ops):
    commutators = {}
    for (j, op1), (k, op2) in combinations(enumerate(ops), r=2):
        res = op1.commutator(op2)
        if res != PauliSentence({}):
            commutators[(j, k)] = res

    return commutators


def adjoint_repr(dla):
    r"""
    Compute the adjoint representation of a dynamical Lie algebra (DLA).

    Given a DLA :math:`\{G_1, G_2, .. G_\mathfrak{d} \}` of dimension :math:`\mathfrak{d}`,
    the structure constants yield the decomposition of all commutators in terms of DLA elements,

    .. math:: [i G_\alpha, i G_\beta] = \sum_{\gamma = 0}^{\mathfrak{d}-1} f^\gamma_{\alpha, \beta} iG_\gamma.

    The adjoint representation :math:`\left(\text{ad}(iG_\gamma)\right)_{\alpha, \beta} = f^\gamma__{\alpha, \beta}` is given by those structure constants,
    which can be computed via

    .. math:: f^\gamma__{\alpha, \beta} = \frac{\text{tr}\left(i G_\gamma \cdot \left[i G_\alpha, i G_\beta \right] \right)}{\text{tr}\left( G_\gamma G_\gamma \right)}.

    The inputs are assumed to be orthogonal. However, we neither assume nor enforce normalization of the DLA elements
    :math:`G_\alpha`, hence the normalization
    factor :math:`\text{tr}\left( G_\gamma G_\gamma \right)` in the decomposition.

    Args:
        dla (List[PauliSentence]): The (dynamical) Lie algebra for which we want to compute its adjoint representation. DLAs can be generated by a set of
            generators via :func:`~lie_closure`

    Returns:
        matrix: The adjoint representation of shape ``(d, d, d)``.

    **Example**

    Let us generate the DLA of the transverse field Ising model using :func:`~lie_closure`.

    >>> n = 2
    >>> gens = [
    ...     PauliSentence({PauliWord({i:"X", i+1:"X"}): 1.}) for i in range(n-1)
    ... ]
    >>> gens += [
    ...     PauliSentence({PauliWord({i:"Z"}): 1.}) for i in range(n)
    ... ]
    >>> dla = qml.dla.lie_closure(gens)
    >>> print(dla)
    [1.0 * X(0) @ X(1), 1.0 * Z(0), 1.0 * Z(1), -1.0 * Y(0) @ X(1), -1.0 * X(0) @ Y(1), -1.0 * Y(0) @ Y(1)]

    The dimension of the DLA is :math:`\mathfrak{d} = 6`. Hence, the structure constants have shape ``(6, 6, 6)``.

    >>> adjoint_rep = qml.dla.adjoint_repr(dla)
    >>> adjoint_rep.shape
    (6, 6, 6)

    The structure constants tell us the commutation relation between operators in the DLA via

    .. math:: [i G_\alpha, i G_\beta] = \sum_{\gamma = 0}^{\mathfrak{d}-1} f^\gamma_{\alpha, \beta} iG_\gamma.

    Let us confirm those with some examples. Take :math:`[iG_1, iG_3] = [iZ_0, -iY_0 X_1] = i 2 X_0 X_1 = i 2 G_0`, so
    we should have :math:`f^0_{1, 3} = 2`, which is indeed the case.

    >>> adjoint_rep[0, 1, 3]
    2.

    We can also look at the overall adjoint action of the first element of the DLA on other elements, :math:`G_0`, ``dla[0] = X(0) @ X(1)``.
    >>> adjoint_rep[0]
    array([[ 0.,  0.,  0.,  0.,  0.,  0.],
           [-0.,  0.,  0.,  2.,  0.,  0.],
           [-0.,  0.,  0.,  0.,  2.,  0.],
           [-0., -2., -0.,  0.,  0.,  0.],
           [-0., -0., -2.,  0.,  0.,  0.],
           [ 0., -0., -0., -0., -0.,  0.]])

    Note that we neither enforce nor assume normalization by default.

    """
    if any((op.pauli_rep is None) for op in dla):
        raise ValueError(
            f"Cannot compute adjoint representation of non-pauli operators. Received {dla}."
        )

    dla = [op.pauli_rep for op in dla]

    commutators = _all_commutators(dla)

    rep = np.zeros((len(dla), len(dla), len(dla)), dtype=float)
    for i, op in enumerate(dla):
        for (j, k), res in commutators.items():
            value = (1j * (op @ res).trace()).real
            value = value / (op @ op).trace()  # v = ∑ (v · e_j / ||e_j||^2) * e_j
            rep[i, j, k] = value
            rep[i, k, j] = -value

    return rep
