# Copyright 2018-2021 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Contains the classical Jacobian transform
"""
# pylint: disable=import-outside-toplevel
import pennylane as qml
from pennylane import numpy as np


def classical_jacobian(qnode, argnums=None):
    r"""Returns a function to extract the Jacobian
    matrix of the classical part of a QNode.

    This transform allows the classical dependence between the QNode
    arguments and the quantum gate arguments to be extracted.

    Args:
        qnode (.QNode): QNode to compute the (classical) Jacobian of
        argnums (int or list[int]): indices of QNode arguments with respect to which
            the (classical) Jacobian is computed

    Returns:
        function: Function which accepts the same arguments as the QNode.
        When called, this function will return the Jacobian of the QNode
        gate arguments with respect to the QNode arguments indexed by ``argnums``.

    **Example**

    Consider the following QNode:

    >>> @qml.qnode(dev)
    ... def circuit(weights):
    ...     qml.RX(weights[0], wires=0)
    ...     qml.RY(2.5, wires=0)
    ...     qml.RY(0.2 * weights[0], wires=1)
    ...     qml.RZ(weights[1] ** 2, wires=1)
    ...     qml.RX(weights[2], wires=1)
    ...     return qml.expval(qml.PauliZ(0)@qml.PauliZ(1))

    We can use this transform to extract the relationship :math:`f: \mathbb{R}^n \rightarrow
    \mathbb{R}^m` between the input QNode arguments :math:`w` and the gate arguments :math:`g`, for
    a given value of the QNode arguments:

    >>> cjac_fn = qml.transforms.classical_jacobian(circuit)
    >>> weights = np.array([1., 1., 0.6], requires_grad=True)
    >>> cjac = cjac_fn(weights)
    >>> print(cjac)
    [[1.  0.  0. ]
     [0.2 0.  0. ]
     [0.  0.  0. ]
     [0.  1.2 0. ]
     [0.  0.  1. ]]

    The returned Jacobian has rows corresponding to gate arguments, and columns
    corresponding to QNode arguments; that is,

    .. math:: J_{ij} = \frac{\partial}{\partial g_i} f(w_j).

    We can see that:

    - The zeroth element of ``weights`` is repeated on the first two gates generated by the QNode.

    - The third row consisting of all zeros indicates that the third gate ``RY(2.5)`` does not
      depend on the ``weights``.

    - The quadratic dependence of the fourth gate argument yields :math:`2\cdot 0.6=1.2`.

    .. note::

        The QNode is constructed during this operation.

    For a QNode with multiple QNode arguments, the output follows the rules of the Jacobian
    implementation *of the used backend*. This includes the handling of ``argnums``.
    For example, for the JAX backend and two QNode arguments, we have the following output
    formats:

    - ``argnums=None``: Single ``array`` output for the derivative w.r.t the first argument.

    - ``argnums=list[int]``: Tuple of arrays for the derivatives of the chosen arguments.

    - ``argnums=int``: For a single int, the tuple is unpacked and the derivative w.r.t
      the chosen argument is output as a single array.
    """

    def classical_preprocessing(*args, **kwargs):
        """Returns the trainable gate parameters for
        a given QNode input"""
        qnode.construct(args, kwargs)
        return qml.math.stack(qnode.qtape.get_parameters())

    if qnode.interface == "autograd":

        def _jacobian(*args, **kwargs):
            if argnums is None:
                jac = qml.jacobian(classical_preprocessing)(*args, **kwargs)
            else:
                jac = tuple(
                    (
                        qml.jacobian(classical_preprocessing, argnum=i)(*args, **kwargs)
                        for i in argnums
                    )
                )
            return jac

        return _jacobian

    if qnode.interface == "torch":
        import torch

        if np.isscalar(argnums):
            argnums = [argnums]

        def _jacobian(*args, **kwargs):  # pylint: disable=unused-argument
            jac = torch.autograd.functional.jacobian(classical_preprocessing, args)
            if argnums is not None:
                jac = tuple((jac[idx] for idx in argnums))
            return jac

        return _jacobian

    if qnode.interface == "jax":
        import jax

        def _jacobian(*args, **kwargs):
            _argnums = 0 if argnums is None else argnums
            return jax.jacobian(classical_preprocessing, argnums=_argnums)(*args, **kwargs)

        return _jacobian

    if qnode.interface == "tf":
        import tensorflow as tf

        def _jacobian(*args, **kwargs):
            if np.isscalar(argnums):
                sub_args = (args[argnums],)
            else:
                sub_args = tuple((args[i] for i in argnums))

            with tf.GradientTape() as tape:
                tape.watch(args)
                gate_params = classical_preprocessing(*args, **kwargs)

            jac = tape.jacobian(gate_params, sub_args)
            return jac

        return _jacobian
